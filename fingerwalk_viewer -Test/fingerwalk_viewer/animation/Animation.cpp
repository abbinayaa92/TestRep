#include "Animation.h"
//#include "GL/freeglut.h"
#include <stack>
#include <GLUtils/GLUtils.h>
#include <ctime>
using namespace std;

const float Animation::kScale = 10.0f;
const float Animation::kScaleX = 1.0f;
const float Animation::kTranslateX = -5.0f;
const float Animation::kTranslateZ = 1.0f;

/*
 * Default constructor
 */
Animation::Animation(FootDrawable *left, FootDrawable *right)
{
	//added by david
	character_orientation = 0;
	compute_joint_parent();

	//lFootPosition = Point3d(0, 0, 0);
	//rFootPosition = Point3d(0, 0, 0);
	left_ = left;
	right_ = right;
	collision=false;
	firstCycle =true;
    InitStates();
    Reset();
	RunTest();
	
	
}

/*
 * Destructor
 */
Animation::~Animation()
{
	character_orientation = 0; //added
}

void Animation::ConvertAbsoluteToRelative(vector<vector<Quaternion2>> *jointQuaternion)
{
    for (int frameIdx = jointQuaternion->size() - 1; frameIdx > 0; --frameIdx) {
        (*jointQuaternion)[frameIdx][0].x -= (*jointQuaternion)[frameIdx - 1][0].x;
        (*jointQuaternion)[frameIdx][0].z -= (*jointQuaternion)[frameIdx - 1][0].z;
    }

    int lastFrameIdx = jointQuaternion->size() - 1;

    /*if (jointQuaternion->size() > 0) {
        (*jointQuaternion)[0][0].x -= (*jointQuaternion)[lastFrameIdx][0].x;
        (*jointQuaternion)[0][0].z -= (*jointQuaternion)[lastFrameIdx][0].z;
    }*/
}


void Animation::ConvertRelativetoAbsolute(vector<vector<Quaternion2>> *jointQuaternion)
{
    for (int frameIdx = 1; frameIdx < jointQuaternion->size(); ++frameIdx) {
        (*jointQuaternion)[frameIdx][0].x += (*jointQuaternion)[frameIdx - 1][0].x;
        (*jointQuaternion)[frameIdx][0].z += (*jointQuaternion)[frameIdx - 1][0].z;
    }
}

void Animation::GetRootPosition(double *x, double *y, double *z)
{
    VectorR3 pos = node_[0].GetGlobalPosition();
    *x = pos.x;
    *y = pos.y;
    *z = pos.z;
}

// return the transition from source to target
// frameCount is the number of frame generated
vector<vector<Quaternion2>> Animation::GetTransition(int firstBegin, int firstEnd,
                                         vector<vector<Quaternion2>> &firstMotion, int secondBegin, int secondEnd,
                                         vector<vector<Quaternion2>> &secondMotion)
{
    vector<vector<Quaternion2>> retVal = secondMotion;

    // the number of frames is the minimum of the two
    int firstLength = firstEnd - firstBegin + 1;
    int secondLength = secondEnd - secondBegin + 1;
    int frameCount = firstLength;
    if (frameCount > secondLength)
        frameCount = secondLength;

    //retVal.resize(secondMotion.size());

    double t = 0.0;
    double step = 1.0 / frameCount;

    // gradual blending
    for (int k = 0; k < frameCount; ++k) {
        int i = k + firstBegin;
        int j = k + secondBegin;

        //retVal[k].resize(firstMotion[i].size());
        // root pos
        retVal[j][0] = firstMotion[i][0] * (1.0 - t) + secondMotion[j][0] * t;
        // rest of joints
        for (int jointIdx = 1; jointIdx < firstMotion[i].size(); ++jointIdx) {
            retVal[j][jointIdx] = firstMotion[i][jointIdx].SlerpWith(secondMotion[j][jointIdx], t);
        }

        t += step;
    }

    return retVal;
}

vector<vector<Quaternion2>> Animation::SpeedUp(double ratio, vector<vector<Quaternion2>> &source)
{
    // create and resize the result
    vector<vector<Quaternion2>> retVal;
    retVal.resize((int) source.size() * ratio);
    for (int frameIdx = 0; frameIdx < retVal.size(); ++frameIdx) {
        retVal[frameIdx].resize(source[0].size());
    }

    // convert source to absolute
    ConvertRelativetoAbsolute(&source);

    for (int i = 0; i < retVal.size(); ++i) {
        double temp = i / ratio;
        int j1 = (int) temp;
        int j2 = j1 + 1;
        assert(j1 < source.size());
        if (j2 >= source.size()) { // if j1 is the last index, just copy
            for (int k = 0; k < retVal[i].size(); ++k) {
                retVal[i][k] = source[j1][k];
            }
        } else { // else, blend between two frames
            retVal[i][0] = source[j1][0] * (j2 - temp) + source[j2][0] * (temp - j1);
            for (int k = 1; k < retVal[i].size(); ++k) {
                retVal[i][k] = source[j1][k].SlerpWith(source[j2][k], temp - j1);
            }
        }
    }

    // convert retVal to relative
    ConvertAbsoluteToRelative(&retVal);

    return retVal;
}

void Animation::InterpolateMotions(vector<vector<Quaternion2>> *firstMotion,
                        vector<vector<Quaternion2>> *secondMotion,
                        vector<vector<Quaternion2>> *currentMotion, double t) {
                            for (int frameIdx = 0; frameIdx < firstMotion->size(); ++frameIdx) {
                                (*currentMotion)[frameIdx][0] = (*firstMotion)[frameIdx][0] * (1.0 - t) + (*secondMotion)[frameIdx][0] * t;
                                for (int jointIdx = 1; jointIdx < (*firstMotion)[frameIdx].size(); ++jointIdx) {
                                    (*currentMotion)[frameIdx][jointIdx] = (*firstMotion)[frameIdx][jointIdx].SlerpWith((*secondMotion)[frameIdx][jointIdx], t);
                                }
                            }
}

vector<vector<Quaternion2>> Animation::MakeLoop(vector<vector<Quaternion2>> &motion, int frameCount, int begin, int end)
{
    // blend the last segment and the first segment
    int lastSegStart = motion.size() - frameCount;
    int firstSegEnd = frameCount - 1;
    double t = 0;
    double step = 1.0 / frameCount;
    for (int k = 0; k < frameCount; ++k) {
        int i = lastSegStart + k;
        int j = k;
        motion[i][0] = motion[i][0] * (1.0 - t) + motion[j][0] * t;
        for (int jointIdx = 1; jointIdx < motion[i].size(); ++jointIdx) {
            motion[i][jointIdx] = motion[i][jointIdx].SlerpWith(motion[j][jointIdx], t);
        }
        t += step;
    }
    // make a new vector and return
    vector<vector<Quaternion2>> retVal;
    if (begin <= end) {
        retVal.resize(end - begin + 1);
        for (int i = 0; i < retVal.size(); ++i) {
            retVal[i] = motion[begin + i];
        }
    } else {
        retVal.resize(motion.size() - end);
        for (int i = 0; i < motion.size() - begin; ++i) {
            retVal[i] = motion[begin + i];
        }
        int e = end;
        for (int i = motion.size() - begin; i < retVal.size(); ++i) {
            retVal[i] = motion[e];
            e++;
        }
    }
    return retVal;
}

void Animation::Downsample(const vector<vector<Quaternion2>> &first, vector<vector<Quaternion2>> *second)
{
    for (int i = 0; i < first.size(); ++i) {
        double temp = i * (0.0 + second->size()) / (0.0 + first.size());
        int j1 = (int) temp;
        int j2 = j1 + 1;
        if (j2 >= second->size()) { // if j1 is the last index, just copy
            for (int k = 0; k < (*second)[i].size(); ++k) {
                (*second)[i][k] = (*second)[j1][k];
            }
        } else { // else, blend between two frames
            (*second)[i][0] = (*second)[j1][0] * (j2 - temp) + (*second)[j2][0] * (temp - j1);
            for (int k = 1; k < (*second)[i].size(); ++k) {
                // slerp
                (*second)[i][k] = (*second)[j1][k].SlerpWith((*second)[j2][k], temp - j1);
            }
        }
    }
    second->resize(first.size());
}

void Animation::RotateFrameBtoOriginal(vector<vector<VectorR3>> *jointTrajectory, vector<vector<Quaternion2>> *jointQuaternion)
{
    Quaternion2 qB = (*jointQuaternion)[0][1];
    Quaternion2 qY = qB.DecomposeRotation2(VectorR3::UnitY);
    qY.toUnit();
    for (int i = 0; i < jointTrajectory->size(); ++i) {
        Quaternion2 qB = (*jointQuaternion)[i][1];
        Quaternion2 newRotation = qY.Inverse() * qB;
        (*jointQuaternion)[i][1] = newRotation;

        VectorR3 newPos = qY.Inverse().rotate((*jointQuaternion)[i][0].ToPoint());
        (*jointQuaternion)[i][0].Set(newPos);
    }
}

Quaternion2 Animation::ConvertEulerAnglesToQuaternion(const VectorR3 &v)
{
    Quaternion2 qX;
    Quaternion2 qY;
    Quaternion2 qZ;
    qX.Set(v.x, VectorR3::UnitX);
    qY.Set(v.y, VectorR3::UnitY);
    qZ.Set(v.z, VectorR3::UnitZ);
    Quaternion2 retVal = qX * qY * qZ;
    return retVal;
}

void Animation::ConvertJointAnglesToQuaternion(const vector<vector<VectorR3>> &source, vector<vector<Quaternion2>> &target)
{
    for (int frameIdx = 0; frameIdx < source.size(); ++frameIdx) {
        target[frameIdx][0].Set(source[frameIdx][0]);
        for (int jointIdx = 1; jointIdx < source[frameIdx].size(); ++jointIdx) {
            Quaternion2 q = ConvertEulerAnglesToQuaternion(source[frameIdx][jointIdx]);
            target[frameIdx][jointIdx] = q;
        }
    }
}

void Animation::TranslateToOrigin(vector<vector<VectorR3>> *jointTrajectory)
{
    double x = (*jointTrajectory)[0][0].x;
    double z = (*jointTrajectory)[0][0].z;

    for (int frameIdx = 0; frameIdx < jointTrajectory->size(); ++frameIdx) {
        (*jointTrajectory)[frameIdx][0].x -= x;
        (*jointTrajectory)[frameIdx][0].z -= z;
    }

    for (int frameIdx = jointTrajectory->size() - 1; frameIdx > 0; --frameIdx) {
        (*jointTrajectory)[frameIdx][0].x -= (*jointTrajectory)[frameIdx - 1][0].x;
        (*jointTrajectory)[frameIdx][0].z -= (*jointTrajectory)[frameIdx - 1][0].z;
    }
}

void Animation::ConvertFromDegreeToRadian(vector<vector<VectorR3>> *jointTrajectory)
{
    // convert all rotation number to radian
    for (int i = 0; i < jointTrajectory->size(); ++i) {
        for (int j = 1; j < (*jointTrajectory)[i].size(); ++j) {
            (*jointTrajectory)[i][j] *= DegreesToRadians;
        }
    }
}

void Animation::ConvertFromRadianToDegree(vector<vector<VectorR3>> *jointTrajectory)
{
    // convert all rotation number to degree
    for (int i = 0; i < jointTrajectory->size(); ++i) {
        for (int j = 1; j < (*jointTrajectory)[i].size(); ++j) {
            (*jointTrajectory)[i][j] *= RadiansToDegrees;
        }
    }
}

/*
 * Reset the data before running each test
 */
void Animation::Reset()
{
    trajectory_.clear();
    jointTrajectory_.clear();
    learnedTargets_.clear();
    step_ = 0;
}

// trim from end
static inline string &rtrim(string &s) {
    s.erase(find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(), s.end());
    return s;
}

// trim from start
static inline string &ltrim(string &s) {
    s.erase(s.begin(), find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace))));
    return s;
}

// trim from both ends
static inline string &trim(string &s) {
    return ltrim(rtrim(s));
}

/*
 * Builds a skeleton from a bvh
 */
void Animation::BuildSkeletonFromBVH(const char *fileName)
{
    const double     kNoRotation[3] = { 0.0, 0.0, 0.0 };
    const VectorR3 kRotationAxes[3] = { VectorR3::UnitX, VectorR3::UnitY, VectorR3::UnitZ };

    ifstream file(fileName);
    string line;

    getline(file, line); // HIERARCHY
    int id = -1;
    string root("ROOT");
    string offset("OFFSET");
    string channels("CHANNELS");
    string joint("JOINT");
    string endSite("End Site");

    stack<int> nodeStack;
    node_.resize(30);
    tree_.Reset();
    string name;

    while (line.compare("MOTION") != 0) {
        getline(file, line);
        line = trim(line);
        if (line.compare(0, offset.length(), offset) == 0) {
            istringstream lineStream(line);
            string temp;
            double x, y, z;
            lineStream >> temp >> x >> y >> z;

            assert(id < 30);
            node_[id] = Node(3, VectorR3(x, y, z), kRotationAxes, kNoRotation, 0.8, JOINT, name);

            if (id > 0)
                tree_.InsertChild(&node_[nodeStack.top()], &node_[id]);
            else if (id == 0)
                tree_.InsertRoot(&node_[id], false);

            nodeStack.push(id);
        } else if (line.compare(0, channels.length(), channels) == 0) {
            continue;
        } else if (line.compare(0, joint.length(), joint) == 0) {
            name = line.substr(root.length() + 1);
            ++id;
            continue;
        } else if (line.compare(0, endSite.length(), endSite) == 0) {
            name = "End";
            ++id;
            continue;
        } else if (line.compare(0, root.length(), root) == 0) {
            name = line.substr(root.length() + 1);
            ++id;
            continue;
        } else if (line[0] == '{') {
            continue;
        } else if (line[0] == '}') {
            nodeStack.pop();
            continue;
        }
    }

    file.close();
}

/*
 * Draw the 3 axes
 */
void Animation::DrawAxes(float size)
{
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_LIGHTING);

    glLineWidth(3.0f);
    glBegin(GL_LINES);
        glColor3f(1.00f, 0.00f, 0.00f);
        glVertex3f(0.0f, 0.0f, 0.0f);
        glVertex3f(size, 0.0f, 0.0f);
        glColor3f(0.00f, 1.00f, 0.00f);
        glVertex3f(0.0f, 0.0f, 0.0f);
        glVertex3f(0.0f, size, 0.0f);
        glColor3f(0.00f, 0.00f, 1.00f);
        glVertex3f(0.0f, 0.0f, 0.0f);
        glVertex3f(0.0f, 0.0f, size);
    glEnd();
    glLineWidth(1.0f);

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
}

/*
 * Draws the skeleton each frame
 */
void Animation::draw()
{
    glPushMatrix();
	tree_.Draw();
    glPopMatrix();
    /*glPushMatrix();
    glTranslatef(kTranslateX, 0.0f, kTranslateZ);
    glScalef(kScaleX, 1.0f, 1.0f);
    glRotatef(90.0f, 0.0f, 1.0f, 0.0f);
    glScalef(1.0 / kScale, 1.0 / kScale, 1.0 / kScale);

    tree_.Draw();
    glPopMatrix();

    DrawAxes(5.0f);

    float footWidth = 0.25f;
    float footLength = 0.5f;
    float footThickness = 0.1f;

    Point3d boxMin(-0.5f * footWidth + trajectory_[step_][0].x, trajectory_[step_][0].y, -0.5f * footLength + trajectory_[step_][0].z);
    Point3d boxMax(0.5f * footWidth + trajectory_[step_][0].x, trajectory_[step_][0].y, 0.5f * footLength + trajectory_[step_][0].z);

    glPushMatrix();
    GLUtils::drawWireFrameBox(boxMin, boxMax);
    glPopMatrix();

    Point3d boxMin2(-0.5f * footWidth + trajectory_[step_][1].x, trajectory_[step_][1].y, -0.5f * footLength + trajectory_[step_][1].z);
    Point3d boxMax2(0.5f * footWidth + trajectory_[step_][1].x, trajectory_[step_][1].y, 0.5f * footLength + trajectory_[step_][1].z);

    glPushMatrix();
    GLUtils::drawWireFrameBox(boxMin2, boxMax2);
    glPopMatrix();*/
}

// to be in the air twice longer, we need to jump four times higher
void Animation::ScaleJumpingHeight(double ratio, vector<vector<Quaternion2>> *jointQuaternion, int begin, int end)
{
    assert(0 <= begin && begin <= end && end < jointQuaternion->size());
    // calculate the number of frames it take to reach max height
    int t = 0;
    for (t = begin; t < end; ++t) {
        double height = (*jointQuaternion)[t][0].ToPoint().y;
        double nextHeight = (*jointQuaternion)[t + 1][0].ToPoint().y;
        if (height < nextHeight) { // if we see the height increases for the first time, break
            break;
        }
        ++t;
    }
    int trueBegin = t; // when the trajectory starts going up
    for (t = trueBegin + 1; t < end; ++t) {
        double height = (*jointQuaternion)[t][0].ToPoint().y;
        double nextHeight = (*jointQuaternion)[t + 1][0].ToPoint().y;
        if (height > nextHeight) { // if we see the height decreases break
            break;
        }
    }
    int half = t; // when we reach max height
    for (t = half + 1; t < end; ++t) {
        double height = (*jointQuaternion)[t][0].ToPoint().y;
        double nextHeight = (*jointQuaternion)[t + 1][0].ToPoint().y;
        if (height < nextHeight) { // if we see the height increases again, break
            break;
        }
    }
    int trueEnd = t;

    const double g = 70.00; // 981 cm/s^2
    int T = trueEnd - trueBegin; // T = time to reach max height
    double v0y = T * g / 2.0 / 60.0;
    v0y = v0y * ratio;
    double y0 = (*jointQuaternion)[trueBegin][0].ToPoint().y;
    //printf("h max: %.3f\n", y0 + v0y * v0y / g);
    for (int t = 0; t <= T; ++t) {
        double desiredHeight = y0 + v0y * t * ratio / 60.0 - 0.5 * g * t * t * ratio * ratio / 3600.0;
        VectorR3 currentPos = (*jointQuaternion)[t + trueBegin][0].ToPoint();
        double currentHeight = currentPos.y;
        // printf("%d : %.3f\n", t + trueBegin, desiredHeight);
        currentPos.y += desiredHeight - currentHeight;
        (*jointQuaternion)[t + trueBegin][0].Set(currentPos);
    }
}

/*
 * Updates the skeleton each frame
 */
bool Animation::Update(int motionType, double stepLengthRatio, double stepDurationRatio,int mode)
{
    bool retVal = false;
    double t = stepLengthRatio;
    double d = stepDurationRatio;
	double portal_array[143][5]={{-2700,-2500,401,601,4},
{-2700,-2500,1002.5,1202.5,4},
{-2700,-2500,1604,1804,4},
{-2700,-2500,2205.5,2405.5,4},
{-2700,-2500,2807,3007,4},
{-2700,-2500,3408.5,3608.5,4},
{-2700,-2500,4010,4210,4},
{-2700,-2500,4611.5,4811.5,4},
{-2700,-2500,5213,5413,4},
{-2700,-2500,5814.5,6014.5,4},
{-2700,-2500,6416,6616,4},
{-2299,-2099,200.5,400.5,8},
{-2299,-2099,802,1002,8},
{-2299,-2099,1403.5,1603.5,8},
{-2299,-2099,2005,2205,8},
{-2299,-2099,2606.5,2806.5,8},
{-2299,-2099,3208,3408,8},
{-2299,-2099,3809.5,4009.5,8},
{-2299,-2099,4411,4611,8},
{-2299,-2099,5012.5,5212.5,8},
{-2299,-2099,5614,5814,8},
{-2299,-2099,6215.5,6415.5,8},
{-2299,-2099,6817,7017,8},
{-1898,-1698,0,200,11},
{-1898,-1698,601.5,801.5,11},
{-1898,-1698,1203,1403,11},
{-1898,-1698,1804.5,2004.5,11},
{-1898,-1698,2406,2606,11},
{-1898,-1698,3007.5,3207.5,11},
{-1898,-1698,3609,3809,11},
{-1898,-1698,4210.5,4410.5,11},
{-1898,-1698,4812,5012,11},
{-1898,-1698,5413.5,5613.5,11},
{-1898,-1698,6015,6215,11},
{-1898,-1698,6616.5,6816.5,11},
{-1697.5,-1497.5,401,601,2},
{-1697.5,-1497.5,1002.5,1202.5,2},
{-1697.5,-1497.5,1604,1804,2},
{-1697.5,-1497.5,2205.5,2405.5,2},
{-1697.5,-1497.5,2807,3007,2},
{-1697.5,-1497.5,3408.5,3608.5,2},
{-1697.5,-1497.5,4010,4210,2},
{-1697.5,-1497.5,4611.5,4811.5,2},
{-1697.5,-1497.5,5213,5413,2},
{-1697.5,-1497.5,5814.5,6014.5,2},
{-1697.5,-1497.5,6416,6616,2},
{-1296.5,-1096.5,200.5,400.5,15},
{-1296.5,-1096.5,802,1002,15},
{-1296.5,-1096.5,1403.5,1603.5,15},
{-1296.5,-1096.5,2005,2205,15},
{-1296.5,-1096.5,2606.5,2806.5,15},
{-1296.5,-1096.5,3208,3408,15},
{-1296.5,-1096.5,3809.5,4009.5,15},
{-1296.5,-1096.5,4411,4611,15},
{-1296.5,-1096.5,5012.5,5212.5,15},
{-1296.5,-1096.5,5614,5814,15},
{-1296.5,-1096.5,6215.5,6415.5,15},
{-1296.5,-1096.5,6817,7017,15},
{-895.5,-695.5,0,200,13},
{-895.5,-695.5,601.5,801.5,13},
{-895.5,-695.5,1203,1403,13},
{-895.5,-695.5,1804.5,2004.5,13},
{-895.5,-695.5,2406,2606,13},
{-895.5,-695.5,3007.5,3207.5,13},
{-895.5,-695.5,3609,3809,13},
{-895.5,-695.5,4210.5,4410.5,13},
{-895.5,-695.5,4812,5012,13},
{-895.5,-695.5,5413.5,5613.5,13},
{-895.5,-695.5,6015,6215,13},
{-895.5,-695.5,6616.5,6816.5,13},
{-294,-94,200.5,400.5,3},
{-294,-94,802,1002,3},
{-294,-94,1403.5,1603.5,3},
{-294,-94,2005,2205,3},
{-294,-94,2606.5,2806.5,3},
{-294,-94,3208,3408,3},
{-294,-94,3809.5,4009.5,3},
{-294,-94,4411,4611,3},
{-294,-94,5012.5,5212.5,3},
{-294,-94,5614,5814,3},
{-294,-94,6215.5,6415.5,3},
{-294,-94,6817,7017,3},
{-93.5,106.5,601.5,801.5,18},
{-93.5,106.5,1203,1403,18},
{-93.5,106.5,1804.5,2004.5,18},
{-93.5,106.5,2406,2606,18},
{-93.5,106.5,3007.5,3207.5,18},
{-93.5,106.5,3609,3809,18},
{-93.5,106.5,4210.5,4410.5,18},
{-93.5,106.5,4812,5012,18},
{-93.5,106.5,5413.5,5613.5,18},
{-93.5,106.5,6015,6215,18},
{-93.5,106.5,6616.5,6816.5,18},
{508,708,200.5,400.5,19},
{508,708,802,1002,19},
{508,708,1403.5,1603.5,19},
{508,708,2005,2205,19},
{508,708,2606.5,2806.5,19},
{508,708,3208,3408,19},
{508,708,3809.5,4009.5,19},
{508,708,4411,4611,19},
{508,708,5012.5,5212.5,19},
{508,708,5614,5814,19},
{508,708,6215.5,6415.5,19},
{508,708,6817,7017,19},
{909,1109,0,200,26},
{909,1109,601.5,801.5,26},
{909,1109,1203,1403,26},
{909,1109,1804.5,2004.5,26},
{909,1109,2406,2606,26},
{909,1109,3007.5,3207.5,26},
{909,1109,3609,3809,26},
{909,1109,4210.5,4410.5,26},
{909,1109,4812,5012,26},
{909,1109,5413.5,5613.5,26},
{909,1109,6015,6215,26},
{909,1109,6616.5,6816.5,26},
{1310,1510,401,601,14},
{1310,1510,1002.5,1202.5,14},
{1310,1510,1604,1804,14},
{1310,1510,2205.5,2405.5,14},
{1310,1510,2807,3007,14},
{1310,1510,3408.5,3608.5,14},
{1310,1510,4010,4210,14},
{1310,1510,4611.5,4811.5,14},
{1310,1510,5213,5413,14},
{1310,1510,5814.5,6014.5,14},
{1310,1510,6416,6616,14},
{1711,1911,401,601,22},
{1711,1911,1403.5,1603.5,22},
{1711,1911,2406,2606,22},
{1711,1911,3408.5,3608.5,22},
{1711,1911,4411,4611,22},
{1711,1911,5413.5,5613.5,22},
{1711,1911,6416,6616,22},
{2112,2312,601.5,801.5,23},
{2112,2312,1403.5,1603.5,23},
{2112,2312,2205.5,2405.5,23},
{2112,2312,3007.5,3207.5,23},
{2112,2312,3809.5,4009.5,23},
{2112,2312,4611.5,4811.5,23},
{2112,2312,5413.5,5613.5,23},
{2112,2312,6215.5,6415.5,23}
};

double walls_array[1733][6]={{-2700,50,5,-2500,50,5},
{-2695,50,0,-2695,50,200},
{-2499.5,50,5,-2299.5,50,5},
{-2499.5,50,195,-2299.5,50,195},
{-2299,50,5,-2099,50,5},
{-2299,50,195,-2099,50,195},
{-2098.5,50,5,-1898.5,50,5},
{-2098.5,50,195,-1898.5,50,195},
{-1898,50,5,-1698,50,5},
{-1898,50,195,-1698,50,195},
{-1697.5,50,5,-1497.5,50,5},
{-1502.5,50,0,-1502.5,50,200},
{-1497,50,5,-1297,50,5},
{-1497,50,195,-1297,50,195},
{-1492,50,0,-1492,50,200},
{-1296.5,50,5,-1096.5,50,5},
{-1101.5,50,0,-1101.5,50,200},
{-1096,50,5,-896,50,5},
{-1091,50,0,-1091,50,200},
{-895.5,50,5,-695.5,50,5},
{-895.5,50,195,-695.5,50,195},
{-695,50,5,-495,50,5},
{-500,50,0,-500,50,200},
{-494.5,50,5,-294.5,50,5},
{-489.5,50,0,-489.5,50,200},
{-294,50,5,-94,50,5},
{-99,50,0,-99,50,200},
{101.5,50,0,101.5,50,200},
{-88.5,50,0,-88.5,50,200},
{107,50,5,307,50,5},
{112,50,0,112,50,200},
{307.5,50,5,507.5,50,5},
{307.5,50,195,507.5,50,195},
{508,50,5,708,50,5},
{508,50,195,708,50,195},
{708.5,50,5,908.5,50,5},
{903.5,50,0,903.5,50,200},
{909,50,5,1109,50,5},
{909,50,195,1109,50,195},
{914,50,0,914,50,200},
{1109.5,50,5,1309.5,50,5},
{1109.5,50,195,1309.5,50,195},
{1310,50,5,1510,50,5},
{1510.5,50,5,1710.5,50,5},
{1711,50,5,1911,50,5},
{1711,50,195,1911,50,195},
{1911.5,50,5,2111.5,50,5},
{2106.5,50,0,2106.5,50,200},
{2112,50,5,2312,50,5},
{2307,50,0,2307,50,200},
{2117,50,0,2117,50,200},
{-2700,50,395.5,-2500,50,395.5},
{-2695,50,200.5,-2695,50,400.5},
{-2499.5,50,205.5,-2299.5,50,205.5},
{-2299,50,205.5,-2099,50,205.5},
{-2299,50,395.5,-2099,50,395.5},
{-2098.5,50,205.5,-1898.5,50,205.5},
{-1903.5,50,200.5,-1903.5,50,400.5},
{-1898,50,205.5,-1698,50,205.5},
{-1703,50,200.5,-1703,50,400.5},
{-1893,50,200.5,-1893,50,400.5},
{-1692.5,50,200.5,-1692.5,50,400.5},
{-1497,50,205.5,-1297,50,205.5},
{-1497,50,395.5,-1297,50,395.5},
{-1101.5,50,200.5,-1101.5,50,400.5},
{-1096,50,395.5,-896,50,395.5},
{-1091,50,200.5,-1091,50,400.5},
{-895.5,50,205.5,-695.5,50,205.5},
{-700.5,50,200.5,-700.5,50,400.5},
{-895.5,50,395.5,-695.5,50,395.5},
{-695,50,395.5,-495,50,395.5},
{-690,50,200.5,-690,50,400.5},
{-299.5,50,200.5,-299.5,50,400.5},
{-99,50,200.5,-99,50,400.5},
{-289,50,200.5,-289,50,400.5},
{101.5,50,200.5,101.5,50,400.5},
{-88.5,50,200.5,-88.5,50,400.5},
{302,50,200.5,302,50,400.5},
{112,50,200.5,112,50,400.5},
{307.5,50,205.5,507.5,50,205.5},
{307.5,50,395.5,507.5,50,395.5},
{312.5,50,200.5,312.5,50,400.5},
{508,50,205.5,708,50,205.5},
{508,50,395.5,708,50,395.5},
{708.5,50,395.5,908.5,50,395.5},
{909,50,205.5,1109,50,205.5},
{1104,50,200.5,1104,50,400.5},
{1109.5,50,205.5,1309.5,50,205.5},
{1114.5,50,200.5,1114.5,50,400.5},
{1505,50,200.5,1505,50,400.5},
{1510.5,50,395.5,1710.5,50,395.5},
{1515.5,50,200.5,1515.5,50,400.5},
{1711,50,205.5,1911,50,205.5},
{1906,50,200.5,1906,50,400.5},
{2106.5,50,200.5,2106.5,50,400.5},
{1916.5,50,200.5,1916.5,50,400.5},
{2307,50,200.5,2307,50,400.5},
{2117,50,200.5,2117,50,400.5},
{-2700,50,406,-2500,50,406},
{-2505,50,401,-2505,50,601},
{-2695,50,401,-2695,50,601},
{-2494.5,50,401,-2494.5,50,601},
{-2299,50,406,-2099,50,406},
{-2104,50,401,-2104,50,601},
{-2299,50,596,-2099,50,596},
{-2098.5,50,596,-1898.5,50,596},
{-2093.5,50,401,-2093.5,50,601},
{-1703,50,401,-1703,50,601},
{-1898,50,596,-1698,50,596},
{-1502.5,50,401,-1502.5,50,601},
{-1692.5,50,401,-1692.5,50,601},
{-1497,50,406,-1297,50,406},
{-1492,50,401,-1492,50,601},
{-1101.5,50,401,-1101.5,50,601},
{-1296.5,50,596,-1096.5,50,596},
{-1096,50,406,-896,50,406},
{-1091,50,401,-1091,50,601},
{-895.5,50,406,-695.5,50,406},
{-895.5,50,596,-695.5,50,596},
{-695,50,406,-495,50,406},
{-500,50,401,-500,50,601},
{-299.5,50,401,-299.5,50,601},
{-489.5,50,401,-489.5,50,601},
{-294,50,596,-94,50,596},
{-289,50,401,-289,50,601},
{101.5,50,401,101.5,50,601},
{-93.5,50,596,106.5,50,596},
{107,50,596,307,50,596},
{112,50,401,112,50,601},
{307.5,50,406,507.5,50,406},
{307.5,50,596,507.5,50,596},
{508,50,406,708,50,406},
{508,50,596,708,50,596},
{708.5,50,406,908.5,50,406},
{903.5,50,401,903.5,50,601},
{708.5,50,596,908.5,50,596},
{909,50,596,1109,50,596},
{914,50,401,914,50,601},
{1304.5,50,401,1304.5,50,601},
{1109.5,50,596,1309.5,50,596},
{1315,50,401,1315,50,601},
{1510.5,50,406,1710.5,50,406},
{1705.5,50,401,1705.5,50,601},
{1906,50,401,1906,50,601},
{1716,50,401,1716,50,601},
{2106.5,50,401,2106.5,50,601},
{1916.5,50,401,1916.5,50,601},
{2307,50,401,2307,50,601},
{2117,50,401,2117,50,601},
{-2505,50,601.5,-2505,50,801.5},
{-2695,50,601.5,-2695,50,801.5},
{-2304.5,50,601.5,-2304.5,50,801.5},
{-2494.5,50,601.5,-2494.5,50,801.5},
{-2299,50,606.5,-2099,50,606.5},
{-2294,50,601.5,-2294,50,801.5},
{-2098.5,50,606.5,-1898.5,50,606.5},
{-2098.5,50,796.5,-1898.5,50,796.5},
{-1898,50,606.5,-1698,50,606.5},
{-1703,50,601.5,-1703,50,801.5},
{-1502.5,50,601.5,-1502.5,50,801.5},
{-1692.5,50,601.5,-1692.5,50,801.5},
{-1497,50,796.5,-1297,50,796.5},
{-1492,50,601.5,-1492,50,801.5},
{-1296.5,50,606.5,-1096.5,50,606.5},
{-1296.5,50,796.5,-1096.5,50,796.5},
{-901,50,601.5,-901,50,801.5},
{-1096,50,796.5,-896,50,796.5},
{-895.5,50,606.5,-695.5,50,606.5},
{-895.5,50,796.5,-695.5,50,796.5},
{-890.5,50,601.5,-890.5,50,801.5},
{-500,50,601.5,-500,50,801.5},
{-494.5,50,796.5,-294.5,50,796.5},
{-489.5,50,601.5,-489.5,50,801.5},
{-294,50,606.5,-94,50,606.5},
{-294,50,796.5,-94,50,796.5},
{-93.5,50,606.5,106.5,50,606.5},
{-93.5,50,796.5,106.5,50,796.5},
{107,50,606.5,307,50,606.5},
{302,50,601.5,302,50,801.5},
{307.5,50,606.5,507.5,50,606.5},
{312.5,50,601.5,312.5,50,801.5},
{508,50,606.5,708,50,606.5},
{703,50,601.5,703,50,801.5},
{708.5,50,606.5,908.5,50,606.5},
{713.5,50,601.5,713.5,50,801.5},
{909,50,606.5,1109,50,606.5},
{1104,50,601.5,1104,50,801.5},
{1109.5,50,606.5,1309.5,50,606.5},
{1114.5,50,601.5,1114.5,50,801.5},
{1505,50,601.5,1505,50,801.5},
{1310,50,796.5,1510,50,796.5},
{1705.5,50,601.5,1705.5,50,801.5},
{1510.5,50,796.5,1710.5,50,796.5},
{1515.5,50,601.5,1515.5,50,801.5},
{1906,50,601.5,1906,50,801.5},
{1716,50,601.5,1716,50,801.5},
{2106.5,50,601.5,2106.5,50,801.5},
{1916.5,50,601.5,1916.5,50,801.5},
{2307,50,601.5,2307,50,801.5},
{2117,50,601.5,2117,50,801.5},
{-2700,50,997,-2500,50,997},
{-2695,50,802,-2695,50,1002},
{-2304.5,50,802,-2304.5,50,1002},
{-2104,50,802,-2104,50,1002},
{-2294,50,802,-2294,50,1002},
{-2098.5,50,807,-1898.5,50,807},
{-1903.5,50,802,-1903.5,50,1002},
{-2093.5,50,802,-2093.5,50,1002},
{-1898,50,997,-1698,50,997},
{-1893,50,802,-1893,50,1002},
{-1502.5,50,802,-1502.5,50,1002},
{-1697.5,50,997,-1497.5,50,997},
{-1497,50,807,-1297,50,807},
{-1497,50,997,-1297,50,997},
{-1492,50,802,-1492,50,1002},
{-1296.5,50,807,-1096.5,50,807},
{-1101.5,50,802,-1101.5,50,1002},
{-1096,50,807,-896,50,807},
{-1091,50,802,-1091,50,1002},
{-895.5,50,807,-695.5,50,807},
{-700.5,50,802,-700.5,50,1002},
{-500,50,802,-500,50,1002},
{-690,50,802,-690,50,1002},
{-494.5,50,807,-294.5,50,807},
{-494.5,50,997,-294.5,50,997},
{-489.5,50,802,-489.5,50,1002},
{-294,50,807,-94,50,807},
{-294,50,997,-94,50,997},
{-93.5,50,807,106.5,50,807},
{101.5,50,802,101.5,50,1002},
{107,50,997,307,50,997},
{112,50,802,112,50,1002},
{502.5,50,802,502.5,50,1002},
{307.5,50,997,507.5,50,997},
{508,50,997,708,50,997},
{513,50,802,513,50,1002},
{903.5,50,802,903.5,50,1002},
{708.5,50,997,908.5,50,997},
{909,50,997,1109,50,997},
{914,50,802,914,50,1002},
{1304.5,50,802,1304.5,50,1002},
{1109.5,50,997,1309.5,50,997},
{1310,50,807,1510,50,807},
{1315,50,802,1315,50,1002},
{1510.5,50,807,1710.5,50,807},
{1705.5,50,802,1705.5,50,1002},
{1906,50,802,1906,50,1002},
{1716,50,802,1716,50,1002},
{2106.5,50,802,2106.5,50,1002},
{1916.5,50,802,1916.5,50,1002},
{2307,50,802,2307,50,1002},
{2117,50,802,2117,50,1002},
{-2700,50,1007.5,-2500,50,1007.5},
{-2505,50,1002.5,-2505,50,1202.5},
{-2695,50,1002.5,-2695,50,1202.5},
{-2304.5,50,1002.5,-2304.5,50,1202.5},
{-2494.5,50,1002.5,-2494.5,50,1202.5},
{-2104,50,1002.5,-2104,50,1202.5},
{-2294,50,1002.5,-2294,50,1202.5},
{-2093.5,50,1002.5,-2093.5,50,1202.5},
{-1898,50,1007.5,-1698,50,1007.5},
{-1898,50,1197.5,-1698,50,1197.5},
{-1697.5,50,1007.5,-1497.5,50,1007.5},
{-1697.5,50,1197.5,-1497.5,50,1197.5},
{-1497,50,1007.5,-1297,50,1007.5},
{-1302,50,1002.5,-1302,50,1202.5},
{-1101.5,50,1002.5,-1101.5,50,1202.5},
{-1291.5,50,1002.5,-1291.5,50,1202.5},
{-901,50,1002.5,-901,50,1202.5},
{-1091,50,1002.5,-1091,50,1202.5},
{-700.5,50,1002.5,-700.5,50,1202.5},
{-890.5,50,1002.5,-890.5,50,1202.5},
{-695,50,1197.5,-495,50,1197.5},
{-690,50,1002.5,-690,50,1202.5},
{-494.5,50,1007.5,-294.5,50,1007.5},
{-494.5,50,1197.5,-294.5,50,1197.5},
{-294,50,1007.5,-94,50,1007.5},
{-99,50,1002.5,-99,50,1202.5},
{101.5,50,1002.5,101.5,50,1202.5},
{-88.5,50,1002.5,-88.5,50,1202.5},
{107,50,1007.5,307,50,1007.5},
{112,50,1002.5,112,50,1202.5},
{307.5,50,1007.5,507.5,50,1007.5},
{508,50,1007.5,708,50,1007.5},
{508,50,1197.5,708,50,1197.5},
{708.5,50,1007.5,908.5,50,1007.5},
{909,50,1007.5,1109,50,1007.5},
{909,50,1197.5,1109,50,1197.5},
{1109.5,50,1007.5,1309.5,50,1007.5},
{1304.5,50,1002.5,1304.5,50,1202.5},
{1109.5,50,1197.5,1309.5,50,1197.5},
{1505,50,1002.5,1505,50,1202.5},
{1315,50,1002.5,1315,50,1202.5},
{1705.5,50,1002.5,1705.5,50,1202.5},
{1515.5,50,1002.5,1515.5,50,1202.5},
{1906,50,1002.5,1906,50,1202.5},
{1716,50,1002.5,1716,50,1202.5},
{1916.5,50,1002.5,1916.5,50,1202.5},
{2307,50,1002.5,2307,50,1202.5},
{2112,50,1197.5,2312,50,1197.5},
{-2700,50,1398,-2500,50,1398},
{-2695,50,1203,-2695,50,1403},
{-2304.5,50,1203,-2304.5,50,1403},
{-2499.5,50,1398,-2299.5,50,1398},
{-2299,50,1398,-2099,50,1398},
{-2294,50,1203,-2294,50,1403},
{-1903.5,50,1203,-1903.5,50,1403},
{-2098.5,50,1398,-1898.5,50,1398},
{-1898,50,1208,-1698,50,1208},
{-1893,50,1203,-1893,50,1403},
{-1697.5,50,1208,-1497.5,50,1208},
{-1697.5,50,1398,-1497.5,50,1398},
{-1302,50,1203,-1302,50,1403},
{-1296.5,50,1398,-1096.5,50,1398},
{-1291.5,50,1203,-1291.5,50,1403},
{-901,50,1203,-901,50,1403},
{-1096,50,1398,-896,50,1398},
{-700.5,50,1203,-700.5,50,1403},
{-890.5,50,1203,-890.5,50,1403},
{-695,50,1208,-495,50,1208},
{-690,50,1203,-690,50,1403},
{-494.5,50,1208,-294.5,50,1208},
{-494.5,50,1398,-294.5,50,1398},
{-99,50,1203,-99,50,1403},
{-93.5,50,1398,106.5,50,1398},
{-88.5,50,1203,-88.5,50,1403},
{302,50,1203,302,50,1403},
{107,50,1398,307,50,1398},
{502.5,50,1203,502.5,50,1403},
{312.5,50,1203,312.5,50,1403},
{508,50,1208,708,50,1208},
{703,50,1203,703,50,1403},
{513,50,1203,513,50,1403},
{903.5,50,1203,903.5,50,1403},
{713.5,50,1203,713.5,50,1403},
{909,50,1208,1109,50,1208},
{914,50,1203,914,50,1403},
{1109.5,50,1208,1309.5,50,1208},
{1109.5,50,1398,1309.5,50,1398},
{1505,50,1203,1505,50,1403},
{1310,50,1398,1510,50,1398},
{1510.5,50,1398,1710.5,50,1398},
{1515.5,50,1203,1515.5,50,1403},
{1906,50,1203,1906,50,1403},
{1711,50,1398,1911,50,1398},
{1916.5,50,1203,1916.5,50,1403},
{2112,50,1208,2312,50,1208},
{2307,50,1203,2307,50,1403},
{2112,50,1398,2312,50,1398},
{-2700,50,1408.5,-2500,50,1408.5},
{-2700,50,1598.5,-2500,50,1598.5},
{-2695,50,1403.5,-2695,50,1603.5},
{-2499.5,50,1408.5,-2299.5,50,1408.5},
{-2499.5,50,1598.5,-2299.5,50,1598.5},
{-2299,50,1408.5,-2099,50,1408.5},
{-2098.5,50,1408.5,-1898.5,50,1408.5},
{-2098.5,50,1598.5,-1898.5,50,1598.5},
{-1898,50,1598.5,-1698,50,1598.5},
{-1697.5,50,1408.5,-1497.5,50,1408.5},
{-1502.5,50,1403.5,-1502.5,50,1603.5},
{-1697.5,50,1598.5,-1497.5,50,1598.5},
{-1497,50,1598.5,-1297,50,1598.5},
{-1492,50,1403.5,-1492,50,1603.5},
{-1296.5,50,1408.5,-1096.5,50,1408.5},
{-1096,50,1408.5,-896,50,1408.5},
{-901,50,1403.5,-901,50,1603.5},
{-700.5,50,1403.5,-700.5,50,1603.5},
{-890.5,50,1403.5,-890.5,50,1603.5},
{-695,50,1598.5,-495,50,1598.5},
{-690,50,1403.5,-690,50,1603.5},
{-494.5,50,1408.5,-294.5,50,1408.5},
{-299.5,50,1403.5,-299.5,50,1603.5},
{-494.5,50,1598.5,-294.5,50,1598.5},
{-294,50,1598.5,-94,50,1598.5},
{-289,50,1403.5,-289,50,1603.5},
{-93.5,50,1408.5,106.5,50,1408.5},
{-93.5,50,1598.5,106.5,50,1598.5},
{107,50,1408.5,307,50,1408.5},
{107,50,1598.5,307,50,1598.5},
{502.5,50,1403.5,502.5,50,1603.5},
{307.5,50,1598.5,507.5,50,1598.5},
{508,50,1598.5,708,50,1598.5},
{513,50,1403.5,513,50,1603.5},
{708.5,50,1598.5,908.5,50,1598.5},
{1104,50,1403.5,1104,50,1603.5},
{909,50,1598.5,1109,50,1598.5},
{1109.5,50,1408.5,1309.5,50,1408.5},
{1114.5,50,1403.5,1114.5,50,1603.5},
{1310,50,1408.5,1510,50,1408.5},
{1310,50,1598.5,1510,50,1598.5},
{1510.5,50,1408.5,1710.5,50,1408.5},
{1510.5,50,1598.5,1710.5,50,1598.5},
{1711,50,1408.5,1911,50,1408.5},
{1906,50,1403.5,1906,50,1603.5},
{1911.5,50,1598.5,2111.5,50,1598.5},
{1916.5,50,1403.5,1916.5,50,1603.5},
{2112,50,1408.5,2312,50,1408.5},
{2307,50,1403.5,2307,50,1603.5},
{-2700,50,1609,-2500,50,1609},
{-2695,50,1604,-2695,50,1804},
{-2499.5,50,1609,-2299.5,50,1609},
{-2304.5,50,1604,-2304.5,50,1804},
{-2299,50,1799,-2099,50,1799},
{-2294,50,1604,-2294,50,1804},
{-2098.5,50,1609,-1898.5,50,1609},
{-2098.5,50,1799,-1898.5,50,1799},
{-1898,50,1609,-1698,50,1609},
{-1703,50,1604,-1703,50,1804},
{-1697.5,50,1609,-1497.5,50,1609},
{-1692.5,50,1604,-1692.5,50,1804},
{-1497,50,1609,-1297,50,1609},
{-1497,50,1799,-1297,50,1799},
{-1101.5,50,1604,-1101.5,50,1804},
{-1296.5,50,1799,-1096.5,50,1799},
{-1096,50,1799,-896,50,1799},
{-1091,50,1604,-1091,50,1804},
{-700.5,50,1604,-700.5,50,1804},
{-895.5,50,1799,-695.5,50,1799},
{-695,50,1609,-495,50,1609},
{-690,50,1604,-690,50,1804},
{-494.5,50,1609,-294.5,50,1609},
{-494.5,50,1799,-294.5,50,1799},
{-294,50,1609,-94,50,1609},
{-99,50,1604,-99,50,1804},
{-93.5,50,1609,106.5,50,1609},
{-88.5,50,1604,-88.5,50,1804},
{107,50,1609,307,50,1609},
{107,50,1799,307,50,1799},
{307.5,50,1609,507.5,50,1609},
{307.5,50,1799,507.5,50,1799},
{508,50,1609,708,50,1609},
{703,50,1604,703,50,1804},
{708.5,50,1609,908.5,50,1609},
{713.5,50,1604,713.5,50,1804},
{909,50,1609,1109,50,1609},
{909,50,1799,1109,50,1799},
{1304.5,50,1604,1304.5,50,1804},
{1310,50,1609,1510,50,1609},
{1315,50,1604,1315,50,1804},
{1510.5,50,1609,1710.5,50,1609},
{1705.5,50,1604,1705.5,50,1804},
{1711,50,1799,1911,50,1799},
{1716,50,1604,1716,50,1804},
{1911.5,50,1609,2111.5,50,1609},
{1911.5,50,1799,2111.5,50,1799},
{2307,50,1604,2307,50,1804},
{2112,50,1799,2312,50,1799},
{-2505,50,1804.5,-2505,50,2004.5},
{-2695,50,1804.5,-2695,50,2004.5},
{-2499.5,50,1999.5,-2299.5,50,1999.5},
{-2494.5,50,1804.5,-2494.5,50,2004.5},
{-2299,50,1809.5,-2099,50,1809.5},
{-2104,50,1804.5,-2104,50,2004.5},
{-2299,50,1999.5,-2099,50,1999.5},
{-2098.5,50,1809.5,-1898.5,50,1809.5},
{-2093.5,50,1804.5,-2093.5,50,2004.5},
{-1703,50,1804.5,-1703,50,2004.5},
{-1898,50,1999.5,-1698,50,1999.5},
{-1697.5,50,1999.5,-1497.5,50,1999.5},
{-1692.5,50,1804.5,-1692.5,50,2004.5},
{-1497,50,1809.5,-1297,50,1809.5},
{-1296.5,50,1809.5,-1096.5,50,1809.5},
{-1101.5,50,1804.5,-1101.5,50,2004.5},
{-1296.5,50,1999.5,-1096.5,50,1999.5},
{-1096,50,1809.5,-896,50,1809.5},
{-1091,50,1804.5,-1091,50,2004.5},
{-895.5,50,1809.5,-695.5,50,1809.5},
{-700.5,50,1804.5,-700.5,50,2004.5},
{-500,50,1804.5,-500,50,2004.5},
{-690,50,1804.5,-690,50,2004.5},
{-494.5,50,1809.5,-294.5,50,1809.5},
{-299.5,50,1804.5,-299.5,50,2004.5},
{-489.5,50,1804.5,-489.5,50,2004.5},
{-99,50,1804.5,-99,50,2004.5},
{-289,50,1804.5,-289,50,2004.5},
{-93.5,50,1999.5,106.5,50,1999.5},
{-88.5,50,1804.5,-88.5,50,2004.5},
{107,50,1809.5,307,50,1809.5},
{107,50,1999.5,307,50,1999.5},
{307.5,50,1809.5,507.5,50,1809.5},
{502.5,50,1804.5,502.5,50,2004.5},
{703,50,1804.5,703,50,2004.5},
{513,50,1804.5,513,50,2004.5},
{708.5,50,1999.5,908.5,50,1999.5},
{713.5,50,1804.5,713.5,50,2004.5},
{909,50,1809.5,1109,50,1809.5},
{1104,50,1804.5,1104,50,2004.5},
{1109.5,50,1999.5,1309.5,50,1999.5},
{1114.5,50,1804.5,1114.5,50,2004.5},
{1505,50,1804.5,1505,50,2004.5},
{1310,50,1999.5,1510,50,1999.5},
{1510.5,50,1999.5,1710.5,50,1999.5},
{1515.5,50,1804.5,1515.5,50,2004.5},
{1711,50,1809.5,1911,50,1809.5},
{1711,50,1999.5,1911,50,1999.5},
{1911.5,50,1809.5,2111.5,50,1809.5},
{2106.5,50,1804.5,2106.5,50,2004.5},
{2112,50,1809.5,2312,50,1809.5},
{2307,50,1804.5,2307,50,2004.5},
{2117,50,1804.5,2117,50,2004.5},
{-2695,50,2005,-2695,50,2205},
{-2499.5,50,2010,-2299.5,50,2010},
{-2299,50,2010,-2099,50,2010},
{-2299,50,2200,-2099,50,2200},
{-1903.5,50,2005,-1903.5,50,2205},
{-2098.5,50,2200,-1898.5,50,2200},
{-1898,50,2010,-1698,50,2010},
{-1893,50,2005,-1893,50,2205},
{-1697.5,50,2010,-1497.5,50,2010},
{-1502.5,50,2005,-1502.5,50,2205},
{-1302,50,2005,-1302,50,2205},
{-1492,50,2005,-1492,50,2205},
{-1296.5,50,2010,-1096.5,50,2010},
{-1291.5,50,2005,-1291.5,50,2205},
{-901,50,2005,-901,50,2205},
{-1096,50,2200,-896,50,2200},
{-700.5,50,2005,-700.5,50,2205},
{-890.5,50,2005,-890.5,50,2205},
{-695,50,2200,-495,50,2200},
{-690,50,2005,-690,50,2205},
{-299.5,50,2005,-299.5,50,2205},
{-494.5,50,2200,-294.5,50,2200},
{-294,50,2200,-94,50,2200},
{-289,50,2005,-289,50,2205},
{-93.5,50,2010,106.5,50,2010},
{101.5,50,2005,101.5,50,2205},
{107,50,2010,307,50,2010},
{302,50,2005,302,50,2205},
{112,50,2005,112,50,2205},
{502.5,50,2005,502.5,50,2205},
{312.5,50,2005,312.5,50,2205},
{513,50,2005,513,50,2205},
{708.5,50,2010,908.5,50,2010},
{903.5,50,2005,903.5,50,2205},
{708.5,50,2200,908.5,50,2200},
{909,50,2200,1109,50,2200},
{914,50,2005,914,50,2205},
{1109.5,50,2010,1309.5,50,2010},
{1304.5,50,2005,1304.5,50,2205},
{1109.5,50,2200,1309.5,50,2200},
{1310,50,2010,1510,50,2010},
{1315,50,2005,1315,50,2205},
{1510.5,50,2010,1710.5,50,2010},
{1510.5,50,2200,1710.5,50,2200},
{1711,50,2010,1911,50,2010},
{1711,50,2200,1911,50,2200},
{2106.5,50,2005,2106.5,50,2205},
{1911.5,50,2200,2111.5,50,2200},
{2307,50,2005,2307,50,2205},
{2117,50,2005,2117,50,2205},
{-2505,50,2205.5,-2505,50,2405.5},
{-2695,50,2205.5,-2695,50,2405.5},
{-2304.5,50,2205.5,-2304.5,50,2405.5},
{-2499.5,50,2400.5,-2299.5,50,2400.5},
{-2494.5,50,2205.5,-2494.5,50,2405.5},
{-2299,50,2210.5,-2099,50,2210.5},
{-2294,50,2205.5,-2294,50,2405.5},
{-2098.5,50,2210.5,-1898.5,50,2210.5},
{-1903.5,50,2205.5,-1903.5,50,2405.5},
{-2098.5,50,2400.5,-1898.5,50,2400.5},
{-1703,50,2205.5,-1703,50,2405.5},
{-1893,50,2205.5,-1893,50,2405.5},
{-1502.5,50,2205.5,-1502.5,50,2405.5},
{-1692.5,50,2205.5,-1692.5,50,2405.5},
{-1302,50,2205.5,-1302,50,2405.5},
{-1497,50,2400.5,-1297,50,2400.5},
{-1492,50,2205.5,-1492,50,2405.5},
{-1296.5,50,2400.5,-1096.5,50,2400.5},
{-1291.5,50,2205.5,-1291.5,50,2405.5},
{-1096,50,2210.5,-896,50,2210.5},
{-901,50,2205.5,-901,50,2405.5},
{-890.5,50,2205.5,-890.5,50,2405.5},
{-695,50,2210.5,-495,50,2210.5},
{-695,50,2400.5,-495,50,2400.5},
{-494.5,50,2210.5,-294.5,50,2210.5},
{-494.5,50,2400.5,-294.5,50,2400.5},
{-294,50,2210.5,-94,50,2210.5},
{-294,50,2400.5,-94,50,2400.5},
{101.5,50,2205.5,101.5,50,2405.5},
{-93.5,50,2400.5,106.5,50,2400.5},
{107,50,2400.5,307,50,2400.5},
{112,50,2205.5,112,50,2405.5},
{502.5,50,2205.5,502.5,50,2405.5},
{307.5,50,2400.5,507.5,50,2400.5},
{703,50,2205.5,703,50,2405.5},
{513,50,2205.5,513,50,2405.5},
{708.5,50,2210.5,908.5,50,2210.5},
{713.5,50,2205.5,713.5,50,2405.5},
{909,50,2210.5,1109,50,2210.5},
{909,50,2400.5,1109,50,2400.5},
{1109.5,50,2210.5,1309.5,50,2210.5},
{1109.5,50,2400.5,1309.5,50,2400.5},
{1310,50,2400.5,1510,50,2400.5},
{1510.5,50,2210.5,1710.5,50,2210.5},
{1510.5,50,2400.5,1710.5,50,2400.5},
{1711,50,2210.5,1911,50,2210.5},
{1711,50,2400.5,1911,50,2400.5},
{1911.5,50,2210.5,2111.5,50,2210.5},
{2106.5,50,2205.5,2106.5,50,2405.5},
{2307,50,2205.5,2307,50,2405.5},
{2117,50,2205.5,2117,50,2405.5},
{-2700,50,2601,-2500,50,2601},
{-2695,50,2406,-2695,50,2606},
{-2499.5,50,2411,-2299.5,50,2411},
{-2104,50,2406,-2104,50,2606},
{-2299,50,2601,-2099,50,2601},
{-2098.5,50,2411,-1898.5,50,2411},
{-2093.5,50,2406,-2093.5,50,2606},
{-1703,50,2406,-1703,50,2606},
{-1898,50,2601,-1698,50,2601},
{-1692.5,50,2406,-1692.5,50,2606},
{-1497,50,2411,-1297,50,2411},
{-1497,50,2601,-1297,50,2601},
{-1296.5,50,2411,-1096.5,50,2411},
{-1296.5,50,2601,-1096.5,50,2601},
{-901,50,2406,-901,50,2606},
{-1096,50,2601,-896,50,2601},
{-700.5,50,2406,-700.5,50,2606},
{-895.5,50,2601,-695.5,50,2601},
{-890.5,50,2406,-890.5,50,2606},
{-695,50,2411,-495,50,2411},
{-690,50,2406,-690,50,2606},
{-494.5,50,2411,-294.5,50,2411},
{-294,50,2411,-94,50,2411},
{-294,50,2601,-94,50,2601},
{-93.5,50,2411,106.5,50,2411},
{-93.5,50,2601,106.5,50,2601},
{107,50,2411,307,50,2411},
{107,50,2601,307,50,2601},
{307.5,50,2411,507.5,50,2411},
{307.5,50,2601,507.5,50,2601},
{508,50,2601,708,50,2601},
{903.5,50,2406,903.5,50,2606},
{708.5,50,2601,908.5,50,2601},
{909,50,2411,1109,50,2411},
{1104,50,2406,1104,50,2606},
{914,50,2406,914,50,2606},
{1109.5,50,2411,1309.5,50,2411},
{1114.5,50,2406,1114.5,50,2606},
{1310,50,2411,1510,50,2411},
{1310,50,2601,1510,50,2601},
{1510.5,50,2411,1710.5,50,2411},
{1510.5,50,2601,1710.5,50,2601},
{1711,50,2411,1911,50,2411},
{1906,50,2406,1906,50,2606},
{1911.5,50,2601,2111.5,50,2601},
{1916.5,50,2406,1916.5,50,2606},
{2307,50,2406,2307,50,2606},
{-2700,50,2611.5,-2500,50,2611.5},
{-2695,50,2606.5,-2695,50,2806.5},
{-2304.5,50,2606.5,-2304.5,50,2806.5},
{-2499.5,50,2801.5,-2299.5,50,2801.5},
{-2299,50,2611.5,-2099,50,2611.5},
{-2299,50,2801.5,-2099,50,2801.5},
{-2294,50,2606.5,-2294,50,2806.5},
{-2098.5,50,2801.5,-1898.5,50,2801.5},
{-1898,50,2611.5,-1698,50,2611.5},
{-1703,50,2606.5,-1703,50,2806.5},
{-1502.5,50,2606.5,-1502.5,50,2806.5},
{-1692.5,50,2606.5,-1692.5,50,2806.5},
{-1497,50,2611.5,-1297,50,2611.5},
{-1492,50,2606.5,-1492,50,2806.5},
{-1296.5,50,2611.5,-1096.5,50,2611.5},
{-1296.5,50,2801.5,-1096.5,50,2801.5},
{-1096,50,2611.5,-896,50,2611.5},
{-1096,50,2801.5,-896,50,2801.5},
{-895.5,50,2611.5,-695.5,50,2611.5},
{-700.5,50,2606.5,-700.5,50,2806.5},
{-500,50,2606.5,-500,50,2806.5},
{-690,50,2606.5,-690,50,2806.5},
{-299.5,50,2606.5,-299.5,50,2806.5},
{-489.5,50,2606.5,-489.5,50,2806.5},
{-294,50,2611.5,-94,50,2611.5},
{-99,50,2606.5,-99,50,2806.5},
{-289,50,2606.5,-289,50,2806.5},
{-93.5,50,2611.5,106.5,50,2611.5},
{-88.5,50,2606.5,-88.5,50,2806.5},
{107,50,2611.5,307,50,2611.5},
{107,50,2801.5,307,50,2801.5},
{307.5,50,2611.5,507.5,50,2611.5},
{502.5,50,2606.5,502.5,50,2806.5},
{508,50,2611.5,708,50,2611.5},
{508,50,2801.5,708,50,2801.5},
{513,50,2606.5,513,50,2806.5},
{708.5,50,2611.5,908.5,50,2611.5},
{903.5,50,2606.5,903.5,50,2806.5},
{914,50,2606.5,914,50,2806.5},
{1304.5,50,2606.5,1304.5,50,2806.5},
{1109.5,50,2801.5,1309.5,50,2801.5},
{1310,50,2611.5,1510,50,2611.5},
{1315,50,2606.5,1315,50,2806.5},
{1510.5,50,2611.5,1710.5,50,2611.5},
{1705.5,50,2606.5,1705.5,50,2806.5},
{1711,50,2801.5,1911,50,2801.5},
{1716,50,2606.5,1716,50,2806.5},
{1911.5,50,2611.5,2111.5,50,2611.5},
{2307,50,2606.5,2307,50,2806.5},
{2112,50,2801.5,2312,50,2801.5},
{-2700,50,3002,-2500,50,3002},
{-2695,50,2807,-2695,50,3007},
{-2499.5,50,2812,-2299.5,50,2812},
{-2304.5,50,2807,-2304.5,50,3007},
{-2299,50,2812,-2099,50,2812},
{-2294,50,2807,-2294,50,3007},
{-2098.5,50,2812,-1898.5,50,2812},
{-2098.5,50,3002,-1898.5,50,3002},
{-1703,50,2807,-1703,50,3007},
{-1898,50,3002,-1698,50,3002},
{-1502.5,50,2807,-1502.5,50,3007},
{-1692.5,50,2807,-1692.5,50,3007},
{-1302,50,2807,-1302,50,3007},
{-1492,50,2807,-1492,50,3007},
{-1296.5,50,2812,-1096.5,50,2812},
{-1101.5,50,2807,-1101.5,50,3007},
{-1291.5,50,2807,-1291.5,50,3007},
{-1096,50,2812,-896,50,2812},
{-1091,50,2807,-1091,50,3007},
{-700.5,50,2807,-700.5,50,3007},
{-895.5,50,3002,-695.5,50,3002},
{-500,50,2807,-500,50,3007},
{-690,50,2807,-690,50,3007},
{-494.5,50,3002,-294.5,50,3002},
{-489.5,50,2807,-489.5,50,3007},
{-99,50,2807,-99,50,3007},
{-294,50,3002,-94,50,3002},
{-93.5,50,3002,106.5,50,3002},
{-88.5,50,2807,-88.5,50,3007},
{107,50,2812,307,50,2812},
{302,50,2807,302,50,3007},
{307.5,50,3002,507.5,50,3002},
{312.5,50,2807,312.5,50,3007},
{508,50,2812,708,50,2812},
{703,50,2807,703,50,3007},
{713.5,50,2807,713.5,50,3007},
{909,50,3002,1109,50,3002},
{1109.5,50,2812,1309.5,50,2812},
{1304.5,50,2807,1304.5,50,3007},
{1109.5,50,3002,1309.5,50,3002},
{1505,50,2807,1505,50,3007},
{1315,50,2807,1315,50,3007},
{1510.5,50,3002,1710.5,50,3002},
{1515.5,50,2807,1515.5,50,3007},
{1711,50,2812,1911,50,2812},
{1906,50,2807,1906,50,3007},
{1911.5,50,3002,2111.5,50,3002},
{1916.5,50,2807,1916.5,50,3007},
{2112,50,2812,2312,50,2812},
{2307,50,2807,2307,50,3007},
{2112,50,3002,2312,50,3002},
{-2700,50,3012.5,-2500,50,3012.5},
{-2700,50,3202.5,-2500,50,3202.5},
{-2695,50,3007.5,-2695,50,3207.5},
{-2304.5,50,3007.5,-2304.5,50,3207.5},
{-2499.5,50,3202.5,-2299.5,50,3202.5},
{-2299,50,3202.5,-2099,50,3202.5},
{-2294,50,3007.5,-2294,50,3207.5},
{-2098.5,50,3012.5,-1898.5,50,3012.5},
{-2098.5,50,3202.5,-1898.5,50,3202.5},
{-1898,50,3012.5,-1698,50,3012.5},
{-1703,50,3007.5,-1703,50,3207.5},
{-1502.5,50,3007.5,-1502.5,50,3207.5},
{-1692.5,50,3007.5,-1692.5,50,3207.5},
{-1302,50,3007.5,-1302,50,3207.5},
{-1492,50,3007.5,-1492,50,3207.5},
{-1101.5,50,3007.5,-1101.5,50,3207.5},
{-1291.5,50,3007.5,-1291.5,50,3207.5},
{-901,50,3007.5,-901,50,3207.5},
{-1091,50,3007.5,-1091,50,3207.5},
{-895.5,50,3012.5,-695.5,50,3012.5},
{-700.5,50,3007.5,-700.5,50,3207.5},
{-890.5,50,3007.5,-890.5,50,3207.5},
{-500,50,3007.5,-500,50,3207.5},
{-690,50,3007.5,-690,50,3207.5},
{-494.5,50,3012.5,-294.5,50,3012.5},
{-489.5,50,3007.5,-489.5,50,3207.5},
{-294,50,3012.5,-94,50,3012.5},
{-93.5,50,3012.5,106.5,50,3012.5},
{101.5,50,3007.5,101.5,50,3207.5},
{107,50,3202.5,307,50,3202.5},
{112,50,3007.5,112,50,3207.5},
{307.5,50,3012.5,507.5,50,3012.5},
{502.5,50,3007.5,502.5,50,3207.5},
{703,50,3007.5,703,50,3207.5},
{513,50,3007.5,513,50,3207.5},
{708.5,50,3202.5,908.5,50,3202.5},
{713.5,50,3007.5,713.5,50,3207.5},
{909,50,3012.5,1109,50,3012.5},
{909,50,3202.5,1109,50,3202.5},
{1109.5,50,3012.5,1309.5,50,3012.5},
{1109.5,50,3202.5,1309.5,50,3202.5},
{1505,50,3007.5,1505,50,3207.5},
{1310,50,3202.5,1510,50,3202.5},
{1510.5,50,3012.5,1710.5,50,3012.5},
{1515.5,50,3007.5,1515.5,50,3207.5},
{1906,50,3007.5,1906,50,3207.5},
{1711,50,3202.5,1911,50,3202.5},
{1911.5,50,3012.5,2111.5,50,3012.5},
{1916.5,50,3007.5,1916.5,50,3207.5},
{2112,50,3012.5,2312,50,3012.5},
{2307,50,3007.5,2307,50,3207.5},
{-2700,50,3213,-2500,50,3213},
{-2695,50,3208,-2695,50,3408},
{-2499.5,50,3213,-2299.5,50,3213},
{-2499.5,50,3403,-2299.5,50,3403},
{-2299,50,3213,-2099,50,3213},
{-2299,50,3403,-2099,50,3403},
{-2098.5,50,3213,-1898.5,50,3213},
{-1903.5,50,3208,-1903.5,50,3408},
{-2098.5,50,3403,-1898.5,50,3403},
{-1703,50,3208,-1703,50,3408},
{-1893,50,3208,-1893,50,3408},
{-1502.5,50,3208,-1502.5,50,3408},
{-1697.5,50,3403,-1497.5,50,3403},
{-1692.5,50,3208,-1692.5,50,3408},
{-1497,50,3403,-1297,50,3403},
{-1492,50,3208,-1492,50,3408},
{-1101.5,50,3208,-1101.5,50,3408},
{-1296.5,50,3403,-1096.5,50,3403},
{-901,50,3208,-901,50,3408},
{-1091,50,3208,-1091,50,3408},
{-700.5,50,3208,-700.5,50,3408},
{-890.5,50,3208,-890.5,50,3408},
{-500,50,3208,-500,50,3408},
{-690,50,3208,-690,50,3408},
{-489.5,50,3208,-489.5,50,3408},
{101.5,50,3208,101.5,50,3408},
{107,50,3213,307,50,3213},
{107,50,3403,307,50,3403},
{112,50,3208,112,50,3408},
{502.5,50,3208,502.5,50,3408},
{508,50,3403,708,50,3403},
{513,50,3208,513,50,3408},
{708.5,50,3213,908.5,50,3213},
{903.5,50,3208,903.5,50,3408},
{909,50,3213,1109,50,3213},
{914,50,3208,914,50,3408},
{1109.5,50,3213,1309.5,50,3213},
{1109.5,50,3403,1309.5,50,3403},
{1310,50,3213,1510,50,3213},
{1505,50,3208,1505,50,3408},
{1310,50,3403,1510,50,3403},
{1510.5,50,3403,1710.5,50,3403},
{1515.5,50,3208,1515.5,50,3408},
{1711,50,3213,1911,50,3213},
{1906,50,3208,1906,50,3408},
{2106.5,50,3208,2106.5,50,3408},
{1916.5,50,3208,1916.5,50,3408},
{2307,50,3208,2307,50,3408},
{2112,50,3403,2312,50,3403},
{2117,50,3208,2117,50,3408},
{-2700,50,3603.5,-2500,50,3603.5},
{-2695,50,3408.5,-2695,50,3608.5},
{-2499.5,50,3413.5,-2299.5,50,3413.5},
{-2299,50,3413.5,-2099,50,3413.5},
{-2299,50,3603.5,-2099,50,3603.5},
{-2098.5,50,3413.5,-1898.5,50,3413.5},
{-2098.5,50,3603.5,-1898.5,50,3603.5},
{-1703,50,3408.5,-1703,50,3608.5},
{-1898,50,3603.5,-1698,50,3603.5},
{-1697.5,50,3413.5,-1497.5,50,3413.5},
{-1692.5,50,3408.5,-1692.5,50,3608.5},
{-1497,50,3413.5,-1297,50,3413.5},
{-1497,50,3603.5,-1297,50,3603.5},
{-1296.5,50,3413.5,-1096.5,50,3413.5},
{-1296.5,50,3603.5,-1096.5,50,3603.5},
{-901,50,3408.5,-901,50,3608.5},
{-1096,50,3603.5,-896,50,3603.5},
{-700.5,50,3408.5,-700.5,50,3608.5},
{-890.5,50,3408.5,-890.5,50,3608.5},
{-500,50,3408.5,-500,50,3608.5},
{-690,50,3408.5,-690,50,3608.5},
{-489.5,50,3408.5,-489.5,50,3608.5},
{101.5,50,3408.5,101.5,50,3608.5},
{107,50,3413.5,307,50,3413.5},
{112,50,3408.5,112,50,3608.5},
{502.5,50,3408.5,502.5,50,3608.5},
{307.5,50,3603.5,507.5,50,3603.5},
{508,50,3413.5,708,50,3413.5},
{703,50,3408.5,703,50,3608.5},
{513,50,3408.5,513,50,3608.5},
{708.5,50,3603.5,908.5,50,3603.5},
{713.5,50,3408.5,713.5,50,3608.5},
{909,50,3603.5,1109,50,3603.5},
{1109.5,50,3413.5,1309.5,50,3413.5},
{1109.5,50,3603.5,1309.5,50,3603.5},
{1310,50,3413.5,1510,50,3413.5},
{1310,50,3603.5,1510,50,3603.5},
{1510.5,50,3413.5,1710.5,50,3413.5},
{1510.5,50,3603.5,1710.5,50,3603.5},
{1906,50,3408.5,1906,50,3608.5},
{1711,50,3603.5,1911,50,3603.5},
{1911.5,50,3603.5,2111.5,50,3603.5},
{1916.5,50,3408.5,1916.5,50,3608.5},
{2112,50,3413.5,2312,50,3413.5},
{2307,50,3408.5,2307,50,3608.5},
{-2700,50,3614,-2500,50,3614},
{-2505,50,3609,-2505,50,3809},
{-2695,50,3609,-2695,50,3809},
{-2494.5,50,3609,-2494.5,50,3809},
{-2104,50,3609,-2104,50,3809},
{-2299,50,3804,-2099,50,3804},
{-2098.5,50,3614,-1898.5,50,3614},
{-2093.5,50,3609,-2093.5,50,3809},
{-1898,50,3614,-1698,50,3614},
{-1703,50,3609,-1703,50,3809},
{-1697.5,50,3804,-1497.5,50,3804},
{-1692.5,50,3609,-1692.5,50,3809},
{-1497,50,3614,-1297,50,3614},
{-1296.5,50,3614,-1096.5,50,3614},
{-1296.5,50,3804,-1096.5,50,3804},
{-1096,50,3614,-896,50,3614},
{-901,50,3609,-901,50,3809},
{-895.5,50,3804,-695.5,50,3804},
{-890.5,50,3609,-890.5,50,3809},
{-500,50,3609,-500,50,3809},
{-695,50,3804,-495,50,3804},
{-489.5,50,3609,-489.5,50,3809},
{101.5,50,3609,101.5,50,3809},
{112,50,3609,112,50,3809},
{307.5,50,3614,507.5,50,3614},
{307.5,50,3804,507.5,50,3804},
{508,50,3804,708,50,3804},
{708.5,50,3614,908.5,50,3614},
{708.5,50,3804,908.5,50,3804},
{909,50,3614,1109,50,3614},
{1104,50,3609,1104,50,3809},
{1109.5,50,3614,1309.5,50,3614},
{1114.5,50,3609,1114.5,50,3809},
{1310,50,3614,1510,50,3614},
{1505,50,3609,1505,50,3809},
{1510.5,50,3614,1710.5,50,3614},
{1515.5,50,3609,1515.5,50,3809},
{1711,50,3614,1911,50,3614},
{1711,50,3804,1911,50,3804},
{1911.5,50,3614,2111.5,50,3614},
{1911.5,50,3804,2111.5,50,3804},
{2307,50,3609,2307,50,3809},
{2112,50,3804,2312,50,3804},
{-2695,50,3809.5,-2695,50,4009.5},
{-2304.5,50,3809.5,-2304.5,50,4009.5},
{-2499.5,50,4004.5,-2299.5,50,4004.5},
{-2299,50,3814.5,-2099,50,3814.5},
{-2294,50,3809.5,-2294,50,4009.5},
{-1903.5,50,3809.5,-1903.5,50,4009.5},
{-2098.5,50,4004.5,-1898.5,50,4004.5},
{-1703,50,3809.5,-1703,50,4009.5},
{-1893,50,3809.5,-1893,50,4009.5},
{-1697.5,50,3814.5,-1497.5,50,3814.5},
{-1692.5,50,3809.5,-1692.5,50,4009.5},
{-1302,50,3809.5,-1302,50,4009.5},
{-1497,50,4004.5,-1297,50,4004.5},
{-1296.5,50,3814.5,-1096.5,50,3814.5},
{-1296.5,50,4004.5,-1096.5,50,4004.5},
{-1291.5,50,3809.5,-1291.5,50,4009.5},
{-901,50,3809.5,-901,50,4009.5},
{-1096,50,4004.5,-896,50,4004.5},
{-895.5,50,3814.5,-695.5,50,3814.5},
{-890.5,50,3809.5,-890.5,50,4009.5},
{-695,50,3814.5,-495,50,3814.5},
{-500,50,3809.5,-500,50,4009.5},
{-695,50,4004.5,-495,50,4004.5},
{-494.5,50,4004.5,-294.5,50,4004.5},
{-489.5,50,3809.5,-489.5,50,4009.5},
{-294,50,4004.5,-94,50,4004.5},
{101.5,50,3809.5,101.5,50,4009.5},
{112,50,3809.5,112,50,4009.5},
{307.5,50,3814.5,507.5,50,3814.5},
{502.5,50,3809.5,502.5,50,4009.5},
{508,50,3814.5,708,50,3814.5},
{513,50,3809.5,513,50,4009.5},
{708.5,50,3814.5,908.5,50,3814.5},
{903.5,50,3809.5,903.5,50,4009.5},
{1104,50,3809.5,1104,50,4009.5},
{909,50,4004.5,1109,50,4004.5},
{914,50,3809.5,914,50,4009.5},
{1304.5,50,3809.5,1304.5,50,4009.5},
{1114.5,50,3809.5,1114.5,50,4009.5},
{1310,50,4004.5,1510,50,4004.5},
{1315,50,3809.5,1315,50,4009.5},
{1510.5,50,4004.5,1710.5,50,4004.5},
{1711,50,3814.5,1911,50,3814.5},
{1711,50,4004.5,1911,50,4004.5},
{1911.5,50,3814.5,2111.5,50,3814.5},
{1911.5,50,4004.5,2111.5,50,4004.5},
{2112,50,3814.5,2312,50,3814.5},
{2307,50,3809.5,2307,50,4009.5},
{-2695,50,4010,-2695,50,4210},
{-2499.5,50,4015,-2299.5,50,4015},
{-2304.5,50,4010,-2304.5,50,4210},
{-2294,50,4010,-2294,50,4210},
{-2098.5,50,4015,-1898.5,50,4015},
{-1903.5,50,4010,-1903.5,50,4210},
{-1703,50,4010,-1703,50,4210},
{-1898,50,4205,-1698,50,4205},
{-1893,50,4010,-1893,50,4210},
{-1697.5,50,4205,-1497.5,50,4205},
{-1692.5,50,4010,-1692.5,50,4210},
{-1497,50,4015,-1297,50,4015},
{-1497,50,4205,-1297,50,4205},
{-1296.5,50,4015,-1096.5,50,4015},
{-1296.5,50,4205,-1096.5,50,4205},
{-1096,50,4015,-896,50,4015},
{-1096,50,4205,-896,50,4205},
{-895.5,50,4205,-695.5,50,4205},
{-695,50,4015,-495,50,4015},
{-695,50,4205,-495,50,4205},
{-494.5,50,4015,-294.5,50,4015},
{-494.5,50,4205,-294.5,50,4205},
{-294,50,4015,-94,50,4015},
{-99,50,4010,-99,50,4210},
{-93.5,50,4205,106.5,50,4205},
{-88.5,50,4010,-88.5,50,4210},
{302,50,4010,302,50,4210},
{107,50,4205,307,50,4205},
{502.5,50,4010,502.5,50,4210},
{312.5,50,4010,312.5,50,4210},
{703,50,4010,703,50,4210},
{513,50,4010,513,50,4210},
{708.5,50,4205,908.5,50,4205},
{713.5,50,4010,713.5,50,4210},
{909,50,4015,1109,50,4015},
{909,50,4205,1109,50,4205},
{1304.5,50,4010,1304.5,50,4210},
{1109.5,50,4205,1309.5,50,4205},
{1310,50,4015,1510,50,4015},
{1315,50,4010,1315,50,4210},
{1510.5,50,4015,1710.5,50,4015},
{1510.5,50,4205,1710.5,50,4205},
{1711,50,4015,1911,50,4015},
{1911.5,50,4015,2111.5,50,4015},
{2106.5,50,4010,2106.5,50,4210},
{2307,50,4010,2307,50,4210},
{2117,50,4010,2117,50,4210},
{-2505,50,4210.5,-2505,50,4410.5},
{-2695,50,4210.5,-2695,50,4410.5},
{-2499.5,50,4405.5,-2299.5,50,4405.5},
{-2494.5,50,4210.5,-2494.5,50,4410.5},
{-2104,50,4210.5,-2104,50,4410.5},
{-2299,50,4405.5,-2099,50,4405.5},
{-2098.5,50,4405.5,-1898.5,50,4405.5},
{-2093.5,50,4210.5,-2093.5,50,4410.5},
{-1898,50,4215.5,-1698,50,4215.5},
{-1898,50,4405.5,-1698,50,4405.5},
{-1697.5,50,4215.5,-1497.5,50,4215.5},
{-1502.5,50,4210.5,-1502.5,50,4410.5},
{-1497,50,4215.5,-1297,50,4215.5},
{-1492,50,4210.5,-1492,50,4410.5},
{-1296.5,50,4215.5,-1096.5,50,4215.5},
{-1296.5,50,4405.5,-1096.5,50,4405.5},
{-1096,50,4215.5,-896,50,4215.5},
{-1096,50,4405.5,-896,50,4405.5},
{-895.5,50,4215.5,-695.5,50,4215.5},
{-895.5,50,4405.5,-695.5,50,4405.5},
{-695,50,4215.5,-495,50,4215.5},
{-695,50,4405.5,-495,50,4405.5},
{-494.5,50,4215.5,-294.5,50,4215.5},
{-299.5,50,4210.5,-299.5,50,4410.5},
{-99,50,4210.5,-99,50,4410.5},
{-289,50,4210.5,-289,50,4410.5},
{-93.5,50,4215.5,106.5,50,4215.5},
{-88.5,50,4210.5,-88.5,50,4410.5},
{107,50,4215.5,307,50,4215.5},
{302,50,4210.5,302,50,4410.5},
{502.5,50,4210.5,502.5,50,4410.5},
{312.5,50,4210.5,312.5,50,4410.5},
{508,50,4405.5,708,50,4405.5},
{513,50,4210.5,513,50,4410.5},
{708.5,50,4215.5,908.5,50,4215.5},
{708.5,50,4405.5,908.5,50,4405.5},
{909,50,4215.5,1109,50,4215.5},
{909,50,4405.5,1109,50,4405.5},
{1109.5,50,4215.5,1309.5,50,4215.5},
{1109.5,50,4405.5,1309.5,50,4405.5},
{1505,50,4210.5,1505,50,4410.5},
{1310,50,4405.5,1510,50,4405.5},
{1510.5,50,4215.5,1710.5,50,4215.5},
{1510.5,50,4405.5,1710.5,50,4405.5},
{1515.5,50,4210.5,1515.5,50,4410.5},
{1906,50,4210.5,1906,50,4410.5},
{1711,50,4405.5,1911,50,4405.5},
{2106.5,50,4210.5,2106.5,50,4410.5},
{1911.5,50,4405.5,2111.5,50,4405.5},
{1916.5,50,4210.5,1916.5,50,4410.5},
{2307,50,4210.5,2307,50,4410.5},
{2117,50,4210.5,2117,50,4410.5},
{-2505,50,4411,-2505,50,4611},
{-2695,50,4411,-2695,50,4611},
{-2499.5,50,4416,-2299.5,50,4416},
{-2494.5,50,4411,-2494.5,50,4611},
{-2299,50,4416,-2099,50,4416},
{-2104,50,4411,-2104,50,4611},
{-2098.5,50,4416,-1898.5,50,4416},
{-2098.5,50,4606,-1898.5,50,4606},
{-2093.5,50,4411,-2093.5,50,4611},
{-1898,50,4416,-1698,50,4416},
{-1898,50,4606,-1698,50,4606},
{-1502.5,50,4411,-1502.5,50,4611},
{-1497,50,4606,-1297,50,4606},
{-1492,50,4411,-1492,50,4611},
{-1296.5,50,4416,-1096.5,50,4416},
{-1096,50,4416,-896,50,4416},
{-1096,50,4606,-896,50,4606},
{-895.5,50,4416,-695.5,50,4416},
{-895.5,50,4606,-695.5,50,4606},
{-695,50,4416,-495,50,4416},
{-500,50,4411,-500,50,4611},
{-299.5,50,4411,-299.5,50,4611},
{-489.5,50,4411,-489.5,50,4611},
{-294,50,4606,-94,50,4606},
{-289,50,4411,-289,50,4611},
{101.5,50,4411,101.5,50,4611},
{-93.5,50,4606,106.5,50,4606},
{302,50,4411,302,50,4611},
{112,50,4411,112,50,4611},
{307.5,50,4606,507.5,50,4606},
{312.5,50,4411,312.5,50,4611},
{508,50,4416,708,50,4416},
{508,50,4606,708,50,4606},
{708.5,50,4416,908.5,50,4416},
{909,50,4416,1109,50,4416},
{909,50,4606,1109,50,4606},
{1109.5,50,4416,1309.5,50,4416},
{1109.5,50,4606,1309.5,50,4606},
{1310,50,4416,1510,50,4416},
{1310,50,4606,1510,50,4606},
{1510.5,50,4416,1710.5,50,4416},
{1705.5,50,4411,1705.5,50,4611},
{1711,50,4416,1911,50,4416},
{1716,50,4411,1716,50,4611},
{1911.5,50,4416,2111.5,50,4416},
{2106.5,50,4411,2106.5,50,4611},
{2307,50,4411,2307,50,4611},
{2117,50,4411,2117,50,4611},
{-2505,50,4611.5,-2505,50,4811.5},
{-2700,50,4806.5,-2500,50,4806.5},
{-2695,50,4611.5,-2695,50,4811.5},
{-2304.5,50,4611.5,-2304.5,50,4811.5},
{-2494.5,50,4611.5,-2494.5,50,4811.5},
{-2299,50,4806.5,-2099,50,4806.5},
{-2294,50,4611.5,-2294,50,4811.5},
{-2098.5,50,4616.5,-1898.5,50,4616.5},
{-2098.5,50,4806.5,-1898.5,50,4806.5},
{-1898,50,4616.5,-1698,50,4616.5},
{-1898,50,4806.5,-1698,50,4806.5},
{-1502.5,50,4611.5,-1502.5,50,4811.5},
{-1697.5,50,4806.5,-1497.5,50,4806.5},
{-1497,50,4616.5,-1297,50,4616.5},
{-1492,50,4611.5,-1492,50,4811.5},
{-1101.5,50,4611.5,-1101.5,50,4811.5},
{-1296.5,50,4806.5,-1096.5,50,4806.5},
{-1096,50,4616.5,-896,50,4616.5},
{-901,50,4611.5,-901,50,4811.5},
{-1091,50,4611.5,-1091,50,4811.5},
{-895.5,50,4616.5,-695.5,50,4616.5},
{-890.5,50,4611.5,-890.5,50,4811.5},
{-500,50,4611.5,-500,50,4811.5},
{-695,50,4806.5,-495,50,4806.5},
{-299.5,50,4611.5,-299.5,50,4811.5},
{-489.5,50,4611.5,-489.5,50,4811.5},
{-294,50,4616.5,-94,50,4616.5},
{-289,50,4611.5,-289,50,4811.5},
{-93.5,50,4616.5,106.5,50,4616.5},
{101.5,50,4611.5,101.5,50,4811.5},
{-93.5,50,4806.5,106.5,50,4806.5},
{107,50,4806.5,307,50,4806.5},
{112,50,4611.5,112,50,4811.5},
{307.5,50,4616.5,507.5,50,4616.5},
{307.5,50,4806.5,507.5,50,4806.5},
{508,50,4616.5,708,50,4616.5},
{703,50,4611.5,703,50,4811.5},
{903.5,50,4611.5,903.5,50,4811.5},
{708.5,50,4806.5,908.5,50,4806.5},
{713.5,50,4611.5,713.5,50,4811.5},
{909,50,4616.5,1109,50,4616.5},
{914,50,4611.5,914,50,4811.5},
{1109.5,50,4616.5,1309.5,50,4616.5},
{1109.5,50,4806.5,1309.5,50,4806.5},
{1310,50,4616.5,1510,50,4616.5},
{1505,50,4611.5,1505,50,4811.5},
{1705.5,50,4611.5,1705.5,50,4811.5},
{1515.5,50,4611.5,1515.5,50,4811.5},
{1906,50,4611.5,1906,50,4811.5},
{1716,50,4611.5,1716,50,4811.5},
{1911.5,50,4806.5,2111.5,50,4806.5},
{1916.5,50,4611.5,1916.5,50,4811.5},
{2307,50,4611.5,2307,50,4811.5},
{-2700,50,4817,-2500,50,4817},
{-2695,50,4812,-2695,50,5012},
{-2304.5,50,4812,-2304.5,50,5012},
{-2499.5,50,5007,-2299.5,50,5007},
{-2299,50,4817,-2099,50,4817},
{-2294,50,4812,-2294,50,5012},
{-2098.5,50,4817,-1898.5,50,4817},
{-2098.5,50,5007,-1898.5,50,5007},
{-1898,50,4817,-1698,50,4817},
{-1898,50,5007,-1698,50,5007},
{-1697.5,50,4817,-1497.5,50,4817},
{-1697.5,50,5007,-1497.5,50,5007},
{-1302,50,4812,-1302,50,5012},
{-1497,50,5007,-1297,50,5007},
{-1296.5,50,4817,-1096.5,50,4817},
{-1291.5,50,4812,-1291.5,50,5012},
{-901,50,4812,-901,50,5012},
{-1096,50,5007,-896,50,5007},
{-700.5,50,4812,-700.5,50,5012},
{-890.5,50,4812,-890.5,50,5012},
{-695,50,4817,-495,50,4817},
{-500,50,4812,-500,50,5012},
{-690,50,4812,-690,50,5012},
{-299.5,50,4812,-299.5,50,5012},
{-489.5,50,4812,-489.5,50,5012},
{-294,50,5007,-94,50,5007},
{-289,50,4812,-289,50,5012},
{-93.5,50,4817,106.5,50,4817},
{-93.5,50,5007,106.5,50,5007},
{107,50,4817,307,50,4817},
{302,50,4812,302,50,5012},
{307.5,50,4817,507.5,50,4817},
{312.5,50,4812,312.5,50,5012},
{703,50,4812,703,50,5012},
{508,50,5007,708,50,5007},
{708.5,50,4817,908.5,50,4817},
{713.5,50,4812,713.5,50,5012},
{1104,50,4812,1104,50,5012},
{909,50,5007,1109,50,5007},
{1109.5,50,4817,1309.5,50,4817},
{1304.5,50,4812,1304.5,50,5012},
{1114.5,50,4812,1114.5,50,5012},
{1505,50,4812,1505,50,5012},
{1315,50,4812,1315,50,5012},
{1705.5,50,4812,1705.5,50,5012},
{1515.5,50,4812,1515.5,50,5012},
{1711,50,5007,1911,50,5007},
{1716,50,4812,1716,50,5012},
{1911.5,50,4817,2111.5,50,4817},
{2106.5,50,4812,2106.5,50,5012},
{1911.5,50,5007,2111.5,50,5007},
{2307,50,4812,2307,50,5012},
{2117,50,4812,2117,50,5012},
{-2700,50,5207.5,-2500,50,5207.5},
{-2695,50,5012.5,-2695,50,5212.5},
{-2499.5,50,5017.5,-2299.5,50,5017.5},
{-2499.5,50,5207.5,-2299.5,50,5207.5},
{-2104,50,5012.5,-2104,50,5212.5},
{-2098.5,50,5017.5,-1898.5,50,5017.5},
{-2093.5,50,5012.5,-2093.5,50,5212.5},
{-1898,50,5017.5,-1698,50,5017.5},
{-1898,50,5207.5,-1698,50,5207.5},
{-1697.5,50,5017.5,-1497.5,50,5017.5},
{-1697.5,50,5207.5,-1497.5,50,5207.5},
{-1497,50,5017.5,-1297,50,5017.5},
{-1497,50,5207.5,-1297,50,5207.5},
{-1101.5,50,5012.5,-1101.5,50,5212.5},
{-1296.5,50,5207.5,-1096.5,50,5207.5},
{-1096,50,5017.5,-896,50,5017.5},
{-1091,50,5012.5,-1091,50,5212.5},
{-700.5,50,5012.5,-700.5,50,5212.5},
{-895.5,50,5207.5,-695.5,50,5207.5},
{-500,50,5012.5,-500,50,5212.5},
{-690,50,5012.5,-690,50,5212.5},
{-494.5,50,5207.5,-294.5,50,5207.5},
{-489.5,50,5012.5,-489.5,50,5212.5},
{-294,50,5017.5,-94,50,5017.5},
{-294,50,5207.5,-94,50,5207.5},
{-93.5,50,5017.5,106.5,50,5017.5},
{-93.5,50,5207.5,106.5,50,5207.5},
{302,50,5012.5,302,50,5212.5},
{107,50,5207.5,307,50,5207.5},
{307.5,50,5207.5,507.5,50,5207.5},
{312.5,50,5012.5,312.5,50,5212.5},
{508,50,5017.5,708,50,5017.5},
{903.5,50,5012.5,903.5,50,5212.5},
{708.5,50,5207.5,908.5,50,5207.5},
{909,50,5017.5,1109,50,5017.5},
{1104,50,5012.5,1104,50,5212.5},
{914,50,5012.5,914,50,5212.5},
{1109.5,50,5207.5,1309.5,50,5207.5},
{1114.5,50,5012.5,1114.5,50,5212.5},
{1505,50,5012.5,1505,50,5212.5},
{1310,50,5207.5,1510,50,5207.5},
{1705.5,50,5012.5,1705.5,50,5212.5},
{1515.5,50,5012.5,1515.5,50,5212.5},
{1711,50,5017.5,1911,50,5017.5},
{1716,50,5012.5,1716,50,5212.5},
{1911.5,50,5017.5,2111.5,50,5017.5},
{2106.5,50,5012.5,2106.5,50,5212.5},
{2307,50,5012.5,2307,50,5212.5},
{2117,50,5012.5,2117,50,5212.5},
{-2700,50,5218,-2500,50,5218},
{-2695,50,5213,-2695,50,5413},
{-2499.5,50,5218,-2299.5,50,5218},
{-2304.5,50,5213,-2304.5,50,5413},
{-2499.5,50,5408,-2299.5,50,5408},
{-2294,50,5213,-2294,50,5413},
{-1903.5,50,5213,-1903.5,50,5413},
{-2098.5,50,5408,-1898.5,50,5408},
{-1898,50,5218,-1698,50,5218},
{-1893,50,5213,-1893,50,5413},
{-1697.5,50,5218,-1497.5,50,5218},
{-1502.5,50,5213,-1502.5,50,5413},
{-1497,50,5218,-1297,50,5218},
{-1492,50,5213,-1492,50,5413},
{-1296.5,50,5218,-1096.5,50,5218},
{-1101.5,50,5213,-1101.5,50,5413},
{-901,50,5213,-901,50,5413},
{-1091,50,5213,-1091,50,5413},
{-895.5,50,5218,-695.5,50,5218},
{-890.5,50,5213,-890.5,50,5413},
{-695,50,5408,-495,50,5408},
{-494.5,50,5218,-294.5,50,5218},
{-494.5,50,5408,-294.5,50,5408},
{-294,50,5218,-94,50,5218},
{-93.5,50,5218,106.5,50,5218},
{101.5,50,5213,101.5,50,5413},
{-93.5,50,5408,106.5,50,5408},
{107,50,5218,307,50,5218},
{112,50,5213,112,50,5413},
{307.5,50,5218,507.5,50,5218},
{502.5,50,5213,502.5,50,5413},
{508,50,5408,708,50,5408},
{513,50,5213,513,50,5413},
{708.5,50,5218,908.5,50,5218},
{903.5,50,5213,903.5,50,5413},
{914,50,5213,914,50,5413},
{1109.5,50,5218,1309.5,50,5218},
{1109.5,50,5408,1309.5,50,5408},
{1310,50,5218,1510,50,5218},
{1505,50,5213,1505,50,5413},
{1510.5,50,5408,1710.5,50,5408},
{1515.5,50,5213,1515.5,50,5413},
{1906,50,5213,1906,50,5413},
{2106.5,50,5213,2106.5,50,5413},
{1916.5,50,5213,1916.5,50,5413},
{2307,50,5213,2307,50,5413},
{2117,50,5213,2117,50,5413},
{-2700,50,5608.5,-2500,50,5608.5},
{-2695,50,5413.5,-2695,50,5613.5},
{-2499.5,50,5418.5,-2299.5,50,5418.5},
{-2499.5,50,5608.5,-2299.5,50,5608.5},
{-2104,50,5413.5,-2104,50,5613.5},
{-2299,50,5608.5,-2099,50,5608.5},
{-2098.5,50,5418.5,-1898.5,50,5418.5},
{-2098.5,50,5608.5,-1898.5,50,5608.5},
{-2093.5,50,5413.5,-2093.5,50,5613.5},
{-1703,50,5413.5,-1703,50,5613.5},
{-1502.5,50,5413.5,-1502.5,50,5613.5},
{-1692.5,50,5413.5,-1692.5,50,5613.5},
{-1302,50,5413.5,-1302,50,5613.5},
{-1492,50,5413.5,-1492,50,5613.5},
{-1101.5,50,5413.5,-1101.5,50,5613.5},
{-1291.5,50,5413.5,-1291.5,50,5613.5},
{-901,50,5413.5,-901,50,5613.5},
{-1091,50,5413.5,-1091,50,5613.5},
{-700.5,50,5413.5,-700.5,50,5613.5},
{-890.5,50,5413.5,-890.5,50,5613.5},
{-695,50,5418.5,-495,50,5418.5},
{-695,50,5608.5,-495,50,5608.5},
{-690,50,5413.5,-690,50,5613.5},
{-494.5,50,5418.5,-294.5,50,5418.5},
{-299.5,50,5413.5,-299.5,50,5613.5},
{-99,50,5413.5,-99,50,5613.5},
{-289,50,5413.5,-289,50,5613.5},
{-93.5,50,5418.5,106.5,50,5418.5},
{-88.5,50,5413.5,-88.5,50,5613.5},
{302,50,5413.5,302,50,5613.5},
{107,50,5608.5,307,50,5608.5},
{502.5,50,5413.5,502.5,50,5613.5},
{312.5,50,5413.5,312.5,50,5613.5},
{508,50,5418.5,708,50,5418.5},
{513,50,5413.5,513,50,5613.5},
{903.5,50,5413.5,903.5,50,5613.5},
{708.5,50,5608.5,908.5,50,5608.5},
{909,50,5608.5,1109,50,5608.5},
{914,50,5413.5,914,50,5613.5},
{1109.5,50,5418.5,1309.5,50,5418.5},
{1304.5,50,5413.5,1304.5,50,5613.5},
{1109.5,50,5608.5,1309.5,50,5608.5},
{1505,50,5413.5,1505,50,5613.5},
{1315,50,5413.5,1315,50,5613.5},
{1510.5,50,5418.5,1710.5,50,5418.5},
{1515.5,50,5413.5,1515.5,50,5613.5},
{1906,50,5413.5,1906,50,5613.5},
{1711,50,5608.5,1911,50,5608.5},
{1911.5,50,5608.5,2111.5,50,5608.5},
{1916.5,50,5413.5,1916.5,50,5613.5},
{2307,50,5413.5,2307,50,5613.5},
{2112,50,5608.5,2312,50,5608.5},
{-2700,50,5619,-2500,50,5619},
{-2695,50,5614,-2695,50,5814},
{-2499.5,50,5619,-2299.5,50,5619},
{-2499.5,50,5809,-2299.5,50,5809},
{-2299,50,5619,-2099,50,5619},
{-2098.5,50,5619,-1898.5,50,5619},
{-1903.5,50,5614,-1903.5,50,5814},
{-1703,50,5614,-1703,50,5814},
{-1893,50,5614,-1893,50,5814},
{-1502.5,50,5614,-1502.5,50,5814},
{-1692.5,50,5614,-1692.5,50,5814},
{-1302,50,5614,-1302,50,5814},
{-1492,50,5614,-1492,50,5814},
{-1101.5,50,5614,-1101.5,50,5814},
{-1291.5,50,5614,-1291.5,50,5814},
{-901,50,5614,-901,50,5814},
{-1091,50,5614,-1091,50,5814},
{-890.5,50,5614,-890.5,50,5814},
{-695,50,5619,-495,50,5619},
{-500,50,5614,-500,50,5814},
{-494.5,50,5809,-294.5,50,5809},
{-489.5,50,5614,-489.5,50,5814},
{-294,50,5809,-94,50,5809},
{101.5,50,5614,101.5,50,5814},
{-93.5,50,5809,106.5,50,5809},
{107,50,5619,307,50,5619},
{112,50,5614,112,50,5814},
{502.5,50,5614,502.5,50,5814},
{307.5,50,5809,507.5,50,5809},
{508,50,5809,708,50,5809},
{513,50,5614,513,50,5814},
{708.5,50,5619,908.5,50,5619},
{909,50,5619,1109,50,5619},
{909,50,5809,1109,50,5809},
{1109.5,50,5619,1309.5,50,5619},
{1109.5,50,5809,1309.5,50,5809},
{1505,50,5614,1505,50,5814},
{1310,50,5809,1510,50,5809},
{1515.5,50,5614,1515.5,50,5814},
{1711,50,5619,1911,50,5619},
{1711,50,5809,1911,50,5809},
{1911.5,50,5619,2111.5,50,5619},
{1911.5,50,5809,2111.5,50,5809},
{2112,50,5619,2312,50,5619},
{2307,50,5614,2307,50,5814},
{-2505,50,5814.5,-2505,50,6014.5},
{-2700,50,6009.5,-2500,50,6009.5},
{-2695,50,5814.5,-2695,50,6014.5},
{-2499.5,50,5819.5,-2299.5,50,5819.5},
{-2494.5,50,5814.5,-2494.5,50,6014.5},
{-2104,50,5814.5,-2104,50,6014.5},
{-2299,50,6009.5,-2099,50,6009.5},
{-1903.5,50,5814.5,-1903.5,50,6014.5},
{-2093.5,50,5814.5,-2093.5,50,6014.5},
{-1703,50,5814.5,-1703,50,6014.5},
{-1893,50,5814.5,-1893,50,6014.5},
{-1697.5,50,6009.5,-1497.5,50,6009.5},
{-1692.5,50,5814.5,-1692.5,50,6014.5},
{-1302,50,5814.5,-1302,50,6014.5},
{-1497,50,6009.5,-1297,50,6009.5},
{-1291.5,50,5814.5,-1291.5,50,6014.5},
{-901,50,5814.5,-901,50,6014.5},
{-700.5,50,5814.5,-700.5,50,6014.5},
{-895.5,50,6009.5,-695.5,50,6009.5},
{-890.5,50,5814.5,-890.5,50,6014.5},
{-695,50,6009.5,-495,50,6009.5},
{-690,50,5814.5,-690,50,6014.5},
{-494.5,50,5819.5,-294.5,50,5819.5},
{-494.5,50,6009.5,-294.5,50,6009.5},
{-294,50,5819.5,-94,50,5819.5},
{-99,50,5814.5,-99,50,6014.5},
{-93.5,50,5819.5,106.5,50,5819.5},
{101.5,50,5814.5,101.5,50,6014.5},
{-88.5,50,5814.5,-88.5,50,6014.5},
{302,50,5814.5,302,50,6014.5},
{112,50,5814.5,112,50,6014.5},
{307.5,50,5819.5,507.5,50,5819.5},
{502.5,50,5814.5,502.5,50,6014.5},
{312.5,50,5814.5,312.5,50,6014.5},
{508,50,5819.5,708,50,5819.5},
{513,50,5814.5,513,50,6014.5},
{903.5,50,5814.5,903.5,50,6014.5},
{909,50,5819.5,1109,50,5819.5},
{914,50,5814.5,914,50,6014.5},
{1109.5,50,5819.5,1309.5,50,5819.5},
{1109.5,50,6009.5,1309.5,50,6009.5},
{1310,50,5819.5,1510,50,5819.5},
{1310,50,6009.5,1510,50,6009.5},
{1705.5,50,5814.5,1705.5,50,6014.5},
{1510.5,50,6009.5,1710.5,50,6009.5},
{1711,50,5819.5,1911,50,5819.5},
{1711,50,6009.5,1911,50,6009.5},
{1716,50,5814.5,1716,50,6014.5},
{1911.5,50,5819.5,2111.5,50,5819.5},
{2106.5,50,5814.5,2106.5,50,6014.5},
{2307,50,5814.5,2307,50,6014.5},
{2117,50,5814.5,2117,50,6014.5},
{-2700,50,6020,-2500,50,6020},
{-2695,50,6015,-2695,50,6215},
{-2304.5,50,6015,-2304.5,50,6215},
{-2499.5,50,6210,-2299.5,50,6210},
{-2299,50,6020,-2099,50,6020},
{-2299,50,6210,-2099,50,6210},
{-2294,50,6015,-2294,50,6215},
{-1903.5,50,6015,-1903.5,50,6215},
{-2098.5,50,6210,-1898.5,50,6210},
{-1703,50,6015,-1703,50,6215},
{-1893,50,6015,-1893,50,6215},
{-1697.5,50,6020,-1497.5,50,6020},
{-1692.5,50,6015,-1692.5,50,6215},
{-1497,50,6210,-1297,50,6210},
{-1492,50,6015,-1492,50,6215},
{-1296.5,50,6020,-1096.5,50,6020},
{-1101.5,50,6015,-1101.5,50,6215},
{-901,50,6015,-901,50,6215},
{-1091,50,6015,-1091,50,6215},
{-895.5,50,6020,-695.5,50,6020},
{-890.5,50,6015,-890.5,50,6215},
{-695,50,6020,-495,50,6020},
{-695,50,6210,-495,50,6210},
{-494.5,50,6020,-294.5,50,6020},
{-494.5,50,6210,-294.5,50,6210},
{-99,50,6015,-99,50,6215},
{-294,50,6210,-94,50,6210},
{101.5,50,6015,101.5,50,6215},
{-88.5,50,6015,-88.5,50,6215},
{112,50,6015,112,50,6215},
{502.5,50,6015,502.5,50,6215},
{307.5,50,6210,507.5,50,6210},
{703,50,6015,703,50,6215},
{513,50,6015,513,50,6215},
{903.5,50,6015,903.5,50,6215},
{713.5,50,6015,713.5,50,6215},
{1104,50,6015,1104,50,6215},
{914,50,6015,914,50,6215},
{1109.5,50,6020,1309.5,50,6020},
{1114.5,50,6015,1114.5,50,6215},
{1310,50,6020,1510,50,6020},
{1310,50,6210,1510,50,6210},
{1510.5,50,6020,1710.5,50,6020},
{1510.5,50,6210,1710.5,50,6210},
{1711,50,6020,1911,50,6020},
{1711,50,6210,1911,50,6210},
{2106.5,50,6015,2106.5,50,6215},
{1911.5,50,6210,2111.5,50,6210},
{2307,50,6015,2307,50,6215},
{2117,50,6015,2117,50,6215},
{-2700,50,6410.5,-2500,50,6410.5},
{-2695,50,6215.5,-2695,50,6415.5},
{-2499.5,50,6220.5,-2299.5,50,6220.5},
{-2499.5,50,6410.5,-2299.5,50,6410.5},
{-2299,50,6220.5,-2099,50,6220.5},
{-2098.5,50,6220.5,-1898.5,50,6220.5},
{-2098.5,50,6410.5,-1898.5,50,6410.5},
{-1703,50,6215.5,-1703,50,6415.5},
{-1898,50,6410.5,-1698,50,6410.5},
{-1502.5,50,6215.5,-1502.5,50,6415.5},
{-1692.5,50,6215.5,-1692.5,50,6415.5},
{-1497,50,6220.5,-1297,50,6220.5},
{-1492,50,6215.5,-1492,50,6415.5},
{-1101.5,50,6215.5,-1101.5,50,6415.5},
{-1296.5,50,6410.5,-1096.5,50,6410.5},
{-1091,50,6215.5,-1091,50,6415.5},
{-700.5,50,6215.5,-700.5,50,6415.5},
{-895.5,50,6410.5,-695.5,50,6410.5},
{-695,50,6220.5,-495,50,6220.5},
{-690,50,6215.5,-690,50,6415.5},
{-494.5,50,6220.5,-294.5,50,6220.5},
{-494.5,50,6410.5,-294.5,50,6410.5},
{-294,50,6220.5,-94,50,6220.5},
{-294,50,6410.5,-94,50,6410.5},
{101.5,50,6215.5,101.5,50,6415.5},
{-93.5,50,6410.5,106.5,50,6410.5},
{302,50,6215.5,302,50,6415.5},
{112,50,6215.5,112,50,6415.5},
{307.5,50,6220.5,507.5,50,6220.5},
{502.5,50,6215.5,502.5,50,6415.5},
{312.5,50,6215.5,312.5,50,6415.5},
{703,50,6215.5,703,50,6415.5},
{513,50,6215.5,513,50,6415.5},
{708.5,50,6410.5,908.5,50,6410.5},
{713.5,50,6215.5,713.5,50,6415.5},
{1104,50,6215.5,1104,50,6415.5},
{909,50,6410.5,1109,50,6410.5},
{1304.5,50,6215.5,1304.5,50,6415.5},
{1114.5,50,6215.5,1114.5,50,6415.5},
{1310,50,6220.5,1510,50,6220.5},
{1315,50,6215.5,1315,50,6415.5},
{1510.5,50,6220.5,1710.5,50,6220.5},
{1510.5,50,6410.5,1710.5,50,6410.5},
{1711,50,6220.5,1911,50,6220.5},
{1906,50,6215.5,1906,50,6415.5},
{1911.5,50,6220.5,2111.5,50,6220.5},
{2106.5,50,6215.5,2106.5,50,6415.5},
{1916.5,50,6215.5,1916.5,50,6415.5},
{2307,50,6215.5,2307,50,6415.5},
{2117,50,6215.5,2117,50,6415.5},
{-2700,50,6421,-2500,50,6421},
{-2700,50,6611,-2500,50,6611},
{-2695,50,6416,-2695,50,6616},
{-2499.5,50,6421,-2299.5,50,6421},
{-2304.5,50,6416,-2304.5,50,6616},
{-2299,50,6611,-2099,50,6611},
{-2294,50,6416,-2294,50,6616},
{-2098.5,50,6421,-1898.5,50,6421},
{-1903.5,50,6416,-1903.5,50,6616},
{-1898,50,6421,-1698,50,6421},
{-1893,50,6416,-1893,50,6616},
{-1502.5,50,6416,-1502.5,50,6616},
{-1697.5,50,6611,-1497.5,50,6611},
{-1497,50,6611,-1297,50,6611},
{-1492,50,6416,-1492,50,6616},
{-1296.5,50,6421,-1096.5,50,6421},
{-1296.5,50,6611,-1096.5,50,6611},
{-901,50,6416,-901,50,6616},
{-1096,50,6611,-896,50,6611},
{-895.5,50,6421,-695.5,50,6421},
{-700.5,50,6416,-700.5,50,6616},
{-890.5,50,6416,-890.5,50,6616},
{-695,50,6611,-495,50,6611},
{-690,50,6416,-690,50,6616},
{-494.5,50,6421,-294.5,50,6421},
{-494.5,50,6611,-294.5,50,6611},
{-294,50,6421,-94,50,6421},
{-93.5,50,6421,106.5,50,6421},
{101.5,50,6416,101.5,50,6616},
{112,50,6416,112,50,6616},
{502.5,50,6416,502.5,50,6616},
{307.5,50,6611,507.5,50,6611},
{508,50,6611,708,50,6611},
{513,50,6416,513,50,6616},
{708.5,50,6421,908.5,50,6421},
{708.5,50,6611,908.5,50,6611},
{909,50,6421,1109,50,6421},
{1104,50,6416,1104,50,6616},
{1114.5,50,6416,1114.5,50,6616},
{1505,50,6416,1505,50,6616},
{1310,50,6611,1510,50,6611},
{1510.5,50,6421,1710.5,50,6421},
{1515.5,50,6416,1515.5,50,6616},
{1906,50,6416,1906,50,6616},
{1916.5,50,6416,1916.5,50,6616},
{2307,50,6416,2307,50,6616},
{2112,50,6611,2312,50,6611},
{-2700,50,6621.5,-2500,50,6621.5},
{-2695,50,6616.5,-2695,50,6816.5},
{-2304.5,50,6616.5,-2304.5,50,6816.5},
{-2499.5,50,6811.5,-2299.5,50,6811.5},
{-2299,50,6621.5,-2099,50,6621.5},
{-2294,50,6616.5,-2294,50,6816.5},
{-1903.5,50,6616.5,-1903.5,50,6816.5},
{-2098.5,50,6811.5,-1898.5,50,6811.5},
{-1898,50,6811.5,-1698,50,6811.5},
{-1893,50,6616.5,-1893,50,6816.5},
{-1697.5,50,6621.5,-1497.5,50,6621.5},
{-1697.5,50,6811.5,-1497.5,50,6811.5},
{-1497,50,6621.5,-1297,50,6621.5},
{-1497,50,6811.5,-1297,50,6811.5},
{-1296.5,50,6621.5,-1096.5,50,6621.5},
{-1296.5,50,6811.5,-1096.5,50,6811.5},
{-1096,50,6621.5,-896,50,6621.5},
{-1096,50,6811.5,-896,50,6811.5},
{-895.5,50,6811.5,-695.5,50,6811.5},
{-695,50,6621.5,-495,50,6621.5},
{-494.5,50,6621.5,-294.5,50,6621.5},
{-299.5,50,6616.5,-299.5,50,6816.5},
{-99,50,6616.5,-99,50,6816.5},
{-294,50,6811.5,-94,50,6811.5},
{-289,50,6616.5,-289,50,6816.5},
{-93.5,50,6811.5,106.5,50,6811.5},
{-88.5,50,6616.5,-88.5,50,6816.5},
{302,50,6616.5,302,50,6816.5},
{107,50,6811.5,307,50,6811.5},
{307.5,50,6621.5,507.5,50,6621.5},
{312.5,50,6616.5,312.5,50,6816.5},
{508,50,6621.5,708,50,6621.5},
{708.5,50,6621.5,908.5,50,6621.5},
{903.5,50,6616.5,903.5,50,6816.5},
{708.5,50,6811.5,908.5,50,6811.5},
{1104,50,6616.5,1104,50,6816.5},
{914,50,6616.5,914,50,6816.5},
{1304.5,50,6616.5,1304.5,50,6816.5},
{1114.5,50,6616.5,1114.5,50,6816.5},
{1310,50,6621.5,1510,50,6621.5},
{1505,50,6616.5,1505,50,6816.5},
{1315,50,6616.5,1315,50,6816.5},
{1705.5,50,6616.5,1705.5,50,6816.5},
{1515.5,50,6616.5,1515.5,50,6816.5},
{1906,50,6616.5,1906,50,6816.5},
{1716,50,6616.5,1716,50,6816.5},
{2106.5,50,6616.5,2106.5,50,6816.5},
{1916.5,50,6616.5,1916.5,50,6816.5},
{2112,50,6621.5,2312,50,6621.5},
{2307,50,6616.5,2307,50,6816.5},
{2117,50,6616.5,2117,50,6816.5},
{-2700,50,7012,-2500,50,7012},
{-2695,50,6817,-2695,50,7017},
{-2499.5,50,6822,-2299.5,50,6822},
{-2499.5,50,7012,-2299.5,50,7012},
{-2104,50,6817,-2104,50,7017},
{-2299,50,7012,-2099,50,7012},
{-2098.5,50,6822,-1898.5,50,6822},
{-2098.5,50,7012,-1898.5,50,7012},
{-2093.5,50,6817,-2093.5,50,7017},
{-1898,50,6822,-1698,50,6822},
{-1898,50,7012,-1698,50,7012},
{-1697.5,50,6822,-1497.5,50,6822},
{-1697.5,50,7012,-1497.5,50,7012},
{-1497,50,6822,-1297,50,6822},
{-1497,50,7012,-1297,50,7012},
{-1296.5,50,6822,-1096.5,50,6822},
{-1296.5,50,7012,-1096.5,50,7012},
{-1096,50,6822,-896,50,6822},
{-1096,50,7012,-896,50,7012},
{-895.5,50,6822,-695.5,50,6822},
{-895.5,50,7012,-695.5,50,7012},
{-500,50,6817,-500,50,7017},
{-695,50,7012,-495,50,7012},
{-494.5,50,7012,-294.5,50,7012},
{-489.5,50,6817,-489.5,50,7017},
{-294,50,6822,-94,50,6822},
{-294,50,7012,-94,50,7012},
{-93.5,50,6822,106.5,50,6822},
{-93.5,50,7012,106.5,50,7012},
{107,50,6822,307,50,6822},
{107,50,7012,307,50,7012},
{502.5,50,6817,502.5,50,7017},
{307.5,50,7012,507.5,50,7012},
{508,50,7012,708,50,7012},
{513,50,6817,513,50,7017},
{708.5,50,6822,908.5,50,6822},
{708.5,50,7012,908.5,50,7012},
{909,50,7012,1109,50,7012},
{1304.5,50,6817,1304.5,50,7017},
{1109.5,50,7012,1309.5,50,7012},
{1310,50,7012,1510,50,7012},
{1315,50,6817,1315,50,7017},
{1705.5,50,6817,1705.5,50,7017},
{1510.5,50,7012,1710.5,50,7012},
{1906,50,6817,1906,50,7017},
{1711,50,7012,1911,50,7012},
{1716,50,6817,1716,50,7017},
{1911.5,50,7012,2111.5,50,7012},
{1916.5,50,6817,1916.5,50,7017},
{2307,50,6817,2307,50,7017},
{2112,50,7012,2312,50,7012}
};
    //static bool firstCycle = true;
    static VectorR3 fixedFootPos;
    static int fixedFoot;

    // select the types of motion
    static vector<vector<Quaternion2>> *firstMotion;
    static vector<vector<Quaternion2>> *secondMotion;
    static int previousMotionType = -1;
    static bool isRootMovedLastFrame;

    // if we finish one step
    if (step_ == 0 || step_ == currentMotion_.size() / 2) {
        // save the current motion
        oldMotion_ = currentMotion_;
        int oldHalf = oldMotion_.size() / 2;
        // select the motion type
        if (motionType == WALKING) {
            firstMotion = &jointQuaternions_[WALK_INPLACE];
            secondMotion = &jointQuaternions_[WALK_FORWARD];
        } else if (motionType == WALKING_BACKWARDS) {
            firstMotion = &jointQuaternions_[WALK_INPLACE];
            secondMotion = &jointQuaternions_[WALK_BACKWARD];
        } else if (motionType == RUNNING_FAST) {
            firstMotion = &jointQuaternions_[RUN_NORMAL];
            secondMotion = &jointQuaternions_[RUN_FAST];
        } else if (motionType == JUMPING_SHORT) {
            firstMotion = &jointQuaternions_[JUMP_SHORT_INPLACE];
            secondMotion = &jointQuaternions_[JUMP_SHORT_FORWARD];
			t*=2;
        } else if (motionType == TIPTOEING) {
            t /= 4.0;
            firstMotion = &jointQuaternions_[TIPTOE_INPLACE];
            secondMotion = &jointQuaternions_[TIPTOE_FORWARD];
        } else if (motionType == TIPTOEING_BACKWARDS) {
            t /= 4.0;
            firstMotion = &jointQuaternions_[TIPTOE_INPLACE];
            secondMotion = &jointQuaternions_[TIPTOE_BACKWARD];
        } else if (motionType == PINO_WALKING) {
            firstMotion = &jointQuaternions_[PINO_WALK_INPLACE];
            secondMotion = &jointQuaternions_[PINO_WALK_FORWARD];
        } else if (motionType == PINO_WALKING_BACKWARDS) {
            firstMotion = &jointQuaternions_[PINO_WALK_INPLACE];
            secondMotion = &jointQuaternions_[PINO_WALK_BACKWARD];
        } else if (motionType == LIMPING) {
            firstMotion = &jointQuaternions_[LIMP_INPLACE];
            secondMotion = &jointQuaternions_[LIMP_FORWARD];
        } else if (motionType == LIMPING_BACKWARDS) {
            firstMotion = &jointQuaternions_[LIMP_INPLACE];
            secondMotion = &jointQuaternions_[LIMP_BACKWARD];
        } else if (motionType == JUMPING_LONG) {
            firstMotion = &jointQuaternions_[JUMP_SHORT_FORWARD];
            secondMotion = &jointQuaternions_[JUMP_LONG_FORWARD];
			t*=2;
            d *= 2;
        } else if (motionType == JOGGING) {
            firstMotion = &jointQuaternions_[RUN_INPLACE];
            secondMotion = &jointQuaternions_[JOG];
        } else if (motionType == RUNNING_NORMAL) {
            firstMotion = &jointQuaternions_[JOG];
            secondMotion = &jointQuaternions_[RUN_NORMAL];
        }
		else if (motionType == CATWALK_NORMAL) {
            firstMotion = &jointQuaternions_[CATWALK_FORWARD];
            secondMotion = &jointQuaternions_[CATWALK_FORWARD];
        }
		else if (motionType == MOONWALK) {
            firstMotion = &jointQuaternions_[MOONWALK_FORWARD];
            secondMotion = &jointQuaternions_[MOONWALK_FORWARD];
        }
		else if (motionType == ONE_HOP) {
            firstMotion = &jointQuaternions_[ONE_HOPPING];
            secondMotion = &jointQuaternions_[ONE_HOPPING];
        }
		else if (motionType == TAP) {
            firstMotion = &jointQuaternions_[TAP_DANCE];
            secondMotion = &jointQuaternions_[TAP_DANCE];
        }
		else if (motionType == SPIN) {
            firstMotion = &jointQuaternions_[BALLET_SPIN];
            secondMotion = &jointQuaternions_[BALLET_SPIN];
        }
		else if (motionType == SKATING) {
            firstMotion = &jointQuaternions_[SKATE_FORWARD];
            secondMotion = &jointQuaternions_[SKATE_FORWARD];
        }
		else if (motionType == DUCKING) {
            firstMotion = &jointQuaternions_[DUCK];
            secondMotion = &jointQuaternions_[DUCK];
        }
		else if (motionType == KICKING) {
            firstMotion = &jointQuaternions_[KICK_FORWARD];
            secondMotion = &jointQuaternions_[KICK_FORWARD];
        }
		else if (motionType == MARCHING) {
            firstMotion = &jointQuaternions_[MARCH_FORWARD];
            secondMotion = &jointQuaternions_[MARCH_FORWARD];
        }
		else if (motionType == SIDE_WALKING) {
            firstMotion = &jointQuaternions_[SIDE_WALK];
            secondMotion = &jointQuaternions_[SIDE_WALK];
        }
		else if (motionType == SNEAKING) {
            firstMotion = &jointQuaternions_[SNEAK_FORWARD];
            secondMotion = &jointQuaternions_[SNEAK_FORWARD];
        }
		else if (motionType == SPLITTING) {
            firstMotion = &jointQuaternions_[SPLIT_FORWARD];
            secondMotion = &jointQuaternions_[SPLIT_FORWARD];
        }
		else if (motionType == SITTING) {
            firstMotion = &jointQuaternions_[SIT_FORWARD];
            secondMotion = &jointQuaternions_[SIT_FORWARD];
        }
		else if (motionType == SIDE_JUMPING) {
            firstMotion = &jointQuaternions_[SIDE_JUMP];
            secondMotion = &jointQuaternions_[SIDE_JUMP];
        }
		else if (motionType == BRIDGING) {
            firstMotion = &jointQuaternions_[BRIDGE];
            secondMotion = &jointQuaternions_[BRIDGE];
        }
		else if (motionType == WALKING_INPLACE) {
            firstMotion = &jointQuaternions_[WALK_INPLACE];
            secondMotion = &jointQuaternions_[WALK_INPLACE];
        }
        // interpolate the two motions
		
        currentMotion_.resize(firstMotion->size());
        for (int i = 0; i < currentMotion_.size(); ++i) {
            currentMotion_[i].resize((*firstMotion)[i].size());
        }
        InterpolateMotions(firstMotion, secondMotion, &currentMotion_, t);
        // speed up or slow down
		//changed the following
      //  currentMotion_ = SpeedUp(d/(currentMotion_.size()*0.0083333), currentMotion_);
		 currentMotion_ = SpeedUp(d, currentMotion_);
        // if this is jumping, scale the height
        /*if (motionType == JUMPING_SHORT) {
            if (step_ == 0) {
                ScaleJumpingHeight(d, &currentMotion_, 0, currentMotion_.size() / 2 - 1);
            } else {
                ScaleJumpingHeight(d, &currentMotion_, currentMotion_.size() / 2, currentMotion_.size() - 1);
            }
        }*/
        int newHalf = currentMotion_.size() / 2;
        // blend the previous motion and the current one, if not the first cycle
        if (!firstCycle) {
            tree_.Compute();
            if (step_ == 0) {
                currentMotion_ = GetTransition(0, oldHalf, oldMotion_, 0, newHalf, currentMotion_);
                // save the right foot
                fixedFoot = RIGHT_FOOT;
                fixedFootPos = node_[fixedFoot].GetGlobalPosition();
            } else if (step_ == oldHalf) {
                currentMotion_ = GetTransition(oldHalf, oldMotion_.size() - 1, oldMotion_,
                    newHalf, currentMotion_.size() - 1, currentMotion_);
                step_ = newHalf;
                // save the left foot
                fixedFoot = LEFT_FOOT;
                fixedFootPos = node_[fixedFoot].GetGlobalPosition();
            }
            isRootMovedLastFrame = true;
        }
    }

    // set the position of the root
	//modified
	//character_orientation = 30*asin(1.0)/90; //for testing
    VectorR3 newPos = currentMotion_[step_][0].ToPoint();
	
	
    VectorR3 currPos = node_[0].GetLocalPosition();
	VectorR3 currFootL= node_[L_Toe_End].GetGlobalPosition();
	VectorR3 currFootR= node_[R_Toe_End].GetGlobalPosition();
	/*VectorR3 newFootL= currentMotion_[step_][L_Toe_End].ToPoint();
	VectorR3 newFootR= currentMotion_[step_][R_Toe_End].ToPoint();*/

	VectorR3 *temp= new VectorR3(currPos.x + newPos.x*cos(character_orientation)+newPos.z*sin(character_orientation), newPos.y,
		currPos.z + newPos.z*cos(character_orientation)-newPos.x*sin(character_orientation));
	/*VectorR3 *tempL= new VectorR3(currFootL.x + newFootL.x*cos(character_orientation)+newFootL.z*sin(character_orientation), newFootL.y,
		currFootL.z + newFootL.z*cos(character_orientation)-newFootL.x*sin(character_orientation));
	VectorR3 *tempR= new VectorR3(currFootR.x + newFootR.x*cos(character_orientation)+newFootR.z*sin(character_orientation), newFootR.y,
		currFootR.z + newFootR.z*cos(character_orientation)-newFootR.x*sin(character_orientation));*/
	//cout<<"Current Position:"<<currPos.x<<" "<<currPos.y<<" "<<currPos.z<<endl;
    
	//node_[0].SetPosition(currPos.x + newPos.x, newPos.y, currPos.z + newPos.z);
    //node_[0].SetPosition(0, 32.0, 0);
	if(mode==2)
	{
	for(int i=0;i<1733;i++)
	{
		if((temp->x>=walls_array[i][0]-5 && temp->x<=walls_array[i][3]+5) && (temp->z>=walls_array[i][2]-5 && temp->z<=walls_array[i][5]+5))
		{
			
			cout<<"collision with wall"<<endl;
			collision=true;
			break;
		}
		else
			collision=false;
	}

	if(!collision)
	{
	for(int i=0;i<143;i++)
	{
		if(temp->x >=portal_array[i][0] && temp->x <=portal_array[i][1] && temp->z>=portal_array[i][2] && temp->z <=portal_array[i][3])
		{
			switch(int(portal_array[i][4]))
			{
			case 4:
				if(motionType==TIPTOEING_BACKWARDS || motionType==TIPTOEING)
					collision=false;
				else
					collision=true;
				break;
			case 8:
				if(motionType==LIMPING || motionType==LIMPING_BACKWARDS)
					collision=false;
				else
					collision=true;
				break;
			case 3:
				//if(motionType==JUMPING_SHORT || motionType==JUMPING_LONG)
				//{
					/*if(((temp->z >=portal_array[i][2]+50 && temp->z <=portal_array[i][2]+55) || (temp->z >=portal_array[i][2]+150 && temp->z <=portal_array[i][2]+155))&& ((temp->x >=portal_array[i][0]+20 && temp->x <=portal_array[i][0]+70) || (temp->x >=portal_array[i][0]+130 && temp->x <=portal_array[i][0]+180)) && temp->y<34)
						collision=true;
					else if(((temp->z >=portal_array[i][2]+20 && temp->z <=portal_array[i][2]+25) || (temp->z >=portal_array[i][2]+100 && temp->z <=portal_array[i][2]+105) ||(temp->z >=portal_array[i][2]+180 && temp->z <=portal_array[i][2]+185)) && (temp->x >=portal_array[i][0]+70 && temp->x <=portal_array[i][0]+130) && temp->y<34)
						collision=true;*/
				if(((temp->z >=portal_array[i][2]+30 && temp->z <=portal_array[i][2]+50) || (temp->z >=portal_array[i][2]+130 && temp->z <=portal_array[i][2]+150)) && temp->y<34)
					collision=true;
					//cout<<"ON FIRE"<<endl;
				else
					collision=false;
				/*}
				else
					collision=true;*/
				break;
			case 11:
				if(motionType==JOGGING)
					collision=false;
				else
					collision=true;
				break;
			case 2:
				if(motionType==RUNNING_FAST)
					collision=false;
				else
					collision=true;
				break;
			case 13:
				if(motionType==CATWALK_NORMAL && ((temp->x >=portal_array[i][0]+80 && temp->x <=portal_array[i][0]+120) || (temp->z>=portal_array[i][2]+80 && temp->z <=portal_array[i][2]+120)))
					collision=false;
				else
					collision=true;
				break;
			case 14:
				if(motionType==MOONWALK)
					collision=false;
				else
					collision=true;
				break;
			case 15:
				if(motionType==ONE_HOP)
					collision=false;
				else
					collision=true;
				break;
			case 18:
				if(motionType==SKATING)
					collision=false;
				else
					collision=true;
				break;
			case 19:
				if(motionType==DUCKING)
					collision=false;
				else
					collision=true;
				break;
			case 22:
				if(motionType==SIDE_WALKING && ((temp->x >=portal_array[i][0]+90 && temp->x <=portal_array[i][0]+110) || (temp->z>=portal_array[i][2]+90 && temp->z <=portal_array[i][2]+110)))
					collision=false;
				else
					collision=true;
				break;
			case 23:
				if(motionType==SNEAKING)
					collision=false;
				else
					collision=true;
				break;
			case 26: //SIDE_JUMPING
				if(motionType==SIDE_WALKING && ((temp->x >=portal_array[i][0]+90 && temp->x <=portal_array[i][0]+110) || (temp->z>=portal_array[i][2]+90 && temp->z <=portal_array[i][2]+110)))
					collision=false;
				else
					collision=true;
				break;
			}
		}
	}
	}
	}

	if(!collision)
	{
		node_[0].SetPosition(currPos.x + newPos.x*cos(character_orientation)+newPos.z*sin(character_orientation), newPos.y,
							currPos.z + newPos.z*cos(character_orientation)-newPos.x*sin(character_orientation)); //added
    // set the orientation of the joints
    node_[0].SetQuaternion(Quaternion2().getRotationQuaternion2(character_orientation, VectorR3(0.0, 1.0, 0.0))*currentMotion_[step_][1]); //added
	//node_[0].SetQuaternion(Quaternion2().getRotationQuaternion2(currentMotion_[step_][1]);
    //node_[0].SetQuaternion(Quaternion::IdentityQuaternion);
    for (int i = 1; i < 30; ++i) {
        int j;
        if ((j = node_[i].GetIndex()) != -1) {
            node_[i].SetQuaternion(currentMotion_[step_][j]);
        }
    }

	//added
	//rotate the knee if the ankle is below the ground
	//tree_.Compute();
	//double hAnkleLeft = node_[LEFT_ANKLE].GetGlobalPosition().y;
	//double hAnkleRight = node_[RIGHT_ANKLE].GetGlobalPosition().y;
	//while (hAnkleLeft < 0.0) {
	//	tree_.Compute();
	//	hAnkleLeft = node_[LEFT_ANKLE].GetGlobalPosition().y;
	//	Quaternion2 rot;
 //       //rot.Set(7.0 * -asin(hAnkleLeft / 30.0), VectorR3::UnitX);
	//	if (node_[LEFT_KNEE].GetGlobalPosition().z>node_[LEFT_ANKLE].GetGlobalPosition().z)
	//		rot.Set(0.02, VectorR3::UnitX);
	//	else
	//		rot.Set(-0.02, VectorR3::UnitX);
 //       Quaternion2 q = node_[LEFT_KNEE].GetQuaternion();
 //       q = rot * q;
 //       node_[LEFT_KNEE].SetQuaternion(q);
 //   }
 //   while (hAnkleRight < 0.0) {
	//	tree_.Compute();
	//	hAnkleRight = node_[RIGHT_ANKLE].GetGlobalPosition().y;
 //       Quaternion2 rot;
 //       //rot.Set(7.0 * -asin(hAnkleRight / 30.0), VectorR3::UnitX);
	//	if (node_[RIGHT_KNEE].GetGlobalPosition().z>node_[RIGHT_ANKLE].GetGlobalPosition().z)
	//		rot.Set(0.02, VectorR3::UnitX);
	//	else
	//		rot.Set(-0.02, VectorR3::UnitX);
 //       Quaternion2 q = node_[RIGHT_KNEE].GetQuaternion();
 //       q = rot * q;
 //       node_[RIGHT_KNEE].SetQuaternion(q);
 //   }
	
    // rotate the ankle if the tip is below the ground
    //tree_.Compute();
    //double dLeft = min(node_[LEFT_FOOT].GetGlobalPosition().y, node_[LEFT_TOE].GetGlobalPosition().y);
    //double dRight = min(node_[RIGHT_FOOT].GetGlobalPosition().y, node_[RIGHT_TOE].GetGlobalPosition().y);
    //if (dLeft < 0) {
    //    Quaternion2 rot;
    //    rot.Set(4.0 * -asin(-dLeft / 30.0), VectorR3::UnitX);
    //    Quaternion2 q = node_[LEFT_ANKLE].GetQuaternion();
    //    q = rot * q;
    //    node_[LEFT_ANKLE].SetQuaternion(q);
    //}
    //if (dRight < 0) {
    //    Quaternion2 rot;
    //    rot.Set(4.0 * -asin(-dRight / 30.0), VectorR3::UnitX);
    //    Quaternion2 q = node_[RIGHT_ANKLE].GetQuaternion();
    //    q = rot * q;
    //    node_[RIGHT_ANKLE].SetQuaternion(q);
    //}
	
	tree_.Compute();
	if (node_[L_Foot].GetGlobalPosition().y<1)
	{
		move_joint(Point3d(node_[L_Foot].GetGlobalPosition().x,
						1, node_[L_Foot].GetGlobalPosition().z), L_Foot);
		tree_.Compute();
	}
	if (node_[L_Toe_End].GetGlobalPosition().y<1)
	{
		move_joint(Point3d(node_[L_Toe_End].GetGlobalPosition().x,
						1, node_[L_Toe_End].GetGlobalPosition().z), L_Toe_End);
		tree_.Compute();
	}
	if (node_[R_Foot].GetGlobalPosition().y<1)
	{
		move_joint(Point3d(node_[R_Foot].GetGlobalPosition().x,
						1, node_[R_Foot].GetGlobalPosition().z), R_Foot);
		tree_.Compute();
	}
	if (node_[R_Toe_End].GetGlobalPosition().y<1)
	{
		move_joint(Point3d(node_[R_Toe_End].GetGlobalPosition().x,
						1, node_[R_Toe_End].GetGlobalPosition().z), R_Toe_End);
		tree_.Compute();
	}
	
    // if not the first cycle, try to move the root to prevent foot sliding
    if (!firstCycle) {
        tree_.Compute();
        if (fixedFoot == LEFT_FOOT)
            assert(step_ >= currentMotion_.size() / 2);
        else if (fixedFoot == RIGHT_FOOT)
            assert(step_ < currentMotion_.size() / 2);
        VectorR3 footPos = node_[fixedFoot].GetGlobalPosition();
		//changed
        if (fabs(footPos.y) < 0.5 && isRootMovedLastFrame) { // only move the root if the foot is in contact with the ground
            VectorR3 delta = footPos - fixedFootPos;
            node_[0].AddToTranslation(-delta.x, 0.0, -delta.z);
			//printf("moved\n");
        } else {
            isRootMovedLastFrame = false;
        }
    }

    // go to next frame, or back at the beginning
    ++step_;
    if (step_ >= currentMotion_.size() / 2) {
        firstCycle = false;
    }

    if (step_ == currentMotion_.size() / 2) { // end of half cycle
        retVal = true;
    }

    if (step_ >= currentMotion_.size()) { // end of one cycle
        retVal = true;
        step_ = 0;
    }
	}
	else
		retVal=true;
    return retVal;
}

/*
 * Recomputes the Jacobian
 */
void Animation::RebuildJacobian()
{
    //delete jacobian_;
    jacobian_ = new Jacobian(&tree_, &targets_);
    jacobian_->Reset();
    jacobian_->ComputeJacobian();
}

/*
 * Initializes some data
 */
void Animation::InitStates()
{
    method_ = DLS;
    useJacobianTargets_ = false;
    step_ = 0;
    srand (time(NULL));
}

/*
 * Updates the targets and recalculates the Jacobian
 */
bool Animation::DoUpdateStep(int motionType, double stepLengthRatio, double stepDurationRatio,int mode) {
    return Update(motionType, stepLengthRatio, stepDurationRatio,mode);
    /*if (targets_.empty())
        return;

    if (useJacobianTargets_)
        jacobian_->SetJtargetActive();
    else
        jacobian_->SetJendActive();

    jacobian_->ComputeJacobian();

    switch (method_) {
        case TRANSPOSE:
            jacobian_->CalcDeltaThetasTranspose();
            break;
        case DLS:
            jacobian_->CalcDeltaThetasDLS();
            break;
        case PSEUDOINVERSE:
            jacobian_->CalcDeltaThetasPseudoinverse();
            break;
        case SDLS:
            jacobian_->CalcDeltaThetasSDLS();
            break;
        default:
            jacobian_->ZeroDeltaThetas();
            break;
    }

    jacobian_->UpdateThetas();
    jacobian_->UpdatedSClampValue();*/
}

/*
 * Converts the training data to the new coordinate
 */
void Animation::ConvertTrainingDatatoWilliam()
{
    for (int frameIndex = 0; frameIndex < trajectory_.size(); ++frameIndex) {
        for (int i = 0; i < trajectory_[frameIndex].size(); ++i) {
            trajectory_[frameIndex][i] /= kScale;
            trajectory_[frameIndex][i].x *= kScaleX;
            double temp = trajectory_[frameIndex][i].x;
            trajectory_[frameIndex][i].x = trajectory_[frameIndex][i].z;
            trajectory_[frameIndex][i].z = -temp;
            trajectory_[frameIndex][i].x += kTranslateX;
            trajectory_[frameIndex][i].z += kTranslateZ;
        }
    }
}

/*
 * Converts the feet positions back to mine learning space
 */
void Animation::ConvertFootDataBacktoMine()
{
    for (int frameIndex = 0; frameIndex < trajectory_.size(); ++frameIndex) {
        for (int i = 0; i < trajectory_[frameIndex].size(); ++i) {
            trajectory_[frameIndex][i].z -= kTranslateZ;
            trajectory_[frameIndex][i].x -= kTranslateX;
            double temp = trajectory_[frameIndex][i].x;
            trajectory_[frameIndex][i].x = -trajectory_[frameIndex][i].z;
            trajectory_[frameIndex][i].z = temp;
            trajectory_[frameIndex][i].x /= kScaleX;
            trajectory_[frameIndex][i] *= kScale;
        }
    }
}

/*
 * Builds a human skeleton
 */
void Animation::BuildSkeleton(float size)
{
    const double     kNoRotation[3] = { 0.0, 0.0, 0.0 };
    const VectorR3 kRotationAxes[3] = { VectorR3::UnitX, VectorR3::UnitY, VectorR3::UnitZ };

	const double  x15[3] = {  15.0, 0.0,   0.0 };
	const double xm15[3] = { -15.0, 0.0,   0.0 };
	const double  z90[3] = {   0.0, 0.0,  90.0 };
	const double zm90[3] = {   0.0, 0.0, -90.0 };

	tree_.Reset();
	node_.resize(30);

	node_[0] = Node(3, VectorR3(0.0f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT);  // Root
	tree_.InsertRoot(&node_[0], false);
	node_[1] = Node(3, VectorR3(0.2f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left femur
	tree_.InsertChild(&node_[0], &node_[1]);
	node_[2] = Node(3, VectorR3(0.0f, -0.87f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left tibia
	tree_.InsertChild(&node_[1], &node_[2]);
	node_[3] = Node(3, VectorR3(0.0f, -0.85f, 0.0f) * size, kRotationAxes, x15,
		0.05, JOINT); // Left foot
	tree_.InsertChild(&node_[2], &node_[3]);
	node_[4] = Node(3, VectorR3(0.0f, -0.08f, 0.32f) * size, kRotationAxes, xm15,
		0.05, JOINT); // Left toe
	tree_.InsertChild(&node_[3], &node_[4]);
	node_[5] = Node(3, VectorR3(0.0f, 0.0f, 0.16f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left toe end
	tree_.InsertChild(&node_[4], &node_[5]);
	node_[6] = Node(3, VectorR3(-0.2f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Right femur
	tree_.InsertChild(&node_[0], &node_[6]);
	node_[7] = Node(3, VectorR3(0.0f, -0.87f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Right tibia
	tree_.InsertChild(&node_[6], &node_[7]);
	node_[8] = Node(3, VectorR3(0.0f, -0.85f, 0.0f) * size, kRotationAxes, x15,
		0.05, JOINT); // Right foot
	tree_.InsertChild(&node_[7], &node_[8]);
	node_[9] = Node(3, VectorR3(0.0f, -0.085f, 0.32f) * size, kRotationAxes, xm15,
		0.05, JOINT); // Right toe
	tree_.InsertChild(&node_[8], &node_[9]);
	node_[10] = Node(3, VectorR3(0.0f, 0.0f, 0.16f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Right toe end
	tree_.InsertChild(&node_[9], &node_[10]);
	node_[11] = Node(3, VectorR3(0.0f, 0.002f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Lower back
	tree_.InsertChild(&node_[0], &node_[11]);
	node_[12] = Node(3, VectorR3(0.0f, 0.56f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Thorax
	tree_.InsertChild(&node_[11], &node_[12]);
	node_[13] = Node(3, VectorR3(0.0f, 0.43f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Neck
	tree_.InsertChild(&node_[12], &node_[13]);
	node_[14] = Node(3, VectorR3(0.0f, 0.38f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Head
	tree_.InsertChild(&node_[13], &node_[14]);
	node_[15] = Node(3, VectorR3(0.0f, 0.25f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Head end
	tree_.InsertChild(&node_[14], &node_[15]);
	node_[16] = Node(3, VectorR3(0.0f, 0.43f, 0.0f) * size, kRotationAxes, zm90,
		0.05, JOINT); // Left collar
	tree_.InsertChild(&node_[12], &node_[16]);
	node_[17] = Node(3, VectorR3(0.37f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left humerus
	tree_.InsertChild(&node_[16], &node_[17]);
	node_[18] = Node(3, VectorR3(0.61f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left elbow
	tree_.InsertChild(&node_[17], &node_[18]);
	node_[19] = Node(3, VectorR3(0.47f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left wrist
	tree_.InsertChild(&node_[18], &node_[19]);
	node_[20] = Node(3, VectorR3(0.0f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left thumb
	tree_.InsertChild(&node_[19], &node_[20]);
	node_[21] = Node(3, VectorR3(0.0f, 0.0f, 0.22f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left thumb end
	tree_.InsertChild(&node_[20], &node_[21]);
	node_[22] = Node(3, VectorR3(0.22f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.05, JOINT); // Left wrist end
	tree_.InsertChild(&node_[19], &node_[22]);
	node_[23] = Node(3, VectorR3(0.0f, 0.43f, 0.0f) * size, kRotationAxes, z90,
		0.08, JOINT); // Right collar
	tree_.InsertChild(&node_[12], &node_[23]);
	node_[24] = Node(3, VectorR3(-0.37f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.08, JOINT); // Right humerus
	tree_.InsertChild(&node_[23], &node_[24]);
	node_[25] = Node(3, VectorR3(-0.61f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.08, JOINT); // Right elbow
	tree_.InsertChild(&node_[24], &node_[25]);
	node_[26] = Node(3, VectorR3(-0.47f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.08, JOINT); // Right wrist
	tree_.InsertChild(&node_[25], &node_[26]);
	node_[27] = Node(3, VectorR3(0.0f, 0.0f, 0.0f) * size, kRotationAxes, kNoRotation,
		0.08, JOINT); // Right thumb
	tree_.InsertChild(&node_[26], &node_[27]);
	node_[28] = Node(3, VectorR3(0.0f, 0.0f, 0.22f) * size, kRotationAxes, kNoRotation,
		0.08, JOINT); // Right thumb end
	tree_.InsertChild(&node_[27], &node_[28]);
	node_[29] = Node(3, VectorR3(-0.3f, 0.0, 0.0f) * size, kRotationAxes, kNoRotation,
		0.08, JOINT); // Right wrist end
	tree_.InsertChild(&node_[26], &node_[29]);
}

double Animation::GetRootHeight()
{
    tree_.Compute();
    return node_[0].GetGlobalPosition().y - (node_[3].GetGlobalPosition().y + node_[8].GetGlobalPosition().y) / 2.0;
}

void Animation::SimpleRetarget(double rootHeightTarget, double rootHeightSource, vector<vector<Quaternion2>> *jointQuaternion)
{
    double ratioY = rootHeightSource / rootHeightTarget;
    for (int i = 0; i < jointQuaternion->size(); ++i) {
        VectorR3 pos = (*jointQuaternion)[i][0].ToPoint();
        pos /= ratioY;
        (*jointQuaternion)[i][0].Set(pos);
    }
}

void Animation::ForceNoWristRotation(vector<vector<Quaternion2>> *jointQuaternion)
{
    int leftWristIndex = node_[LEFT_WRIST].GetIndex();
    int rightWristIndex = node_[RIGHT_WRIST].GetIndex();

    for (int frameIndex = 0; frameIndex < jointQuaternion->size(); ++frameIndex) {
        (*jointQuaternion)[frameIndex][leftWristIndex].Set(Quaternion2::IdentityQuaternion2);
        (*jointQuaternion)[frameIndex][rightWristIndex].Set(Quaternion2::IdentityQuaternion2);
    }
}

/*
 * Run the test
 */
void Animation::RunTest()
{

	/* ---------------- read the bridge forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/Bridge.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[BRIDGE] = GetRootHeight();
    AssignIndex();
	cout<<"bridge"<<endl;
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[BRIDGE], "./animation/data/Bridge.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[BRIDGE]);
    ConvertFromDegreeToRadian(&jointTrajectories_[BRIDGE]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[BRIDGE]);
    // resize the quaternions array accordingly
    jointQuaternions_[BRIDGE].resize(jointTrajectories_[BRIDGE].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[BRIDGE].size(); ++frameIdx) {
        jointQuaternions_[BRIDGE][frameIdx].resize(jointTrajectories_[BRIDGE][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[BRIDGE], jointQuaternions_[BRIDGE]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[BRIDGE], &jointQuaternions_[BRIDGE]);
    // make loop
	
    jointQuaternions_[BRIDGE] = MakeLoop(jointQuaternions_[BRIDGE],
        jointQuaternions_[BRIDGE].size() / 3,
        jointQuaternions_[BRIDGE].size() * 2 / 3,
        jointQuaternions_[BRIDGE].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[BRIDGE]);
/* ---------------- read the side jumping forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/SideJump.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[SIDE_JUMP] = GetRootHeight();
    AssignIndex();
	cout<<"sidejump"<<endl;
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[SIDE_JUMP], "./animation/data/SideJump.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[SIDE_JUMP]);
    ConvertFromDegreeToRadian(&jointTrajectories_[SIDE_JUMP]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[SIDE_JUMP]);
    // resize the quaternions array accordingly
    jointQuaternions_[SIDE_JUMP].resize(jointTrajectories_[SIDE_JUMP].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[SIDE_JUMP].size(); ++frameIdx) {
        jointQuaternions_[SIDE_JUMP][frameIdx].resize(jointTrajectories_[SIDE_JUMP][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[SIDE_JUMP], jointQuaternions_[SIDE_JUMP]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[SIDE_JUMP], &jointQuaternions_[SIDE_JUMP]);
    // make loop
	
    jointQuaternions_[SIDE_JUMP] = MakeLoop(jointQuaternions_[SIDE_JUMP],
        jointQuaternions_[SIDE_JUMP].size() / 3,
        jointQuaternions_[SIDE_JUMP].size() * 2 / 3,
        jointQuaternions_[SIDE_JUMP].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[SIDE_JUMP]);


/* ---------------- read the sit forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/sitstand.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[SIT_FORWARD] = GetRootHeight();
    AssignIndex();
    // read joint trajectories and process discontinuities
	//sitstand
	cout<<"sitstand"<<endl;
    ReadBVHFile(&jointTrajectories_[SIT_FORWARD], "./animation/data/sitstand.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[SIT_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[SIT_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[SIT_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[SIT_FORWARD].resize(jointTrajectories_[SIT_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[SIT_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[SIT_FORWARD][frameIdx].resize(jointTrajectories_[SIT_FORWARD][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[SIT_FORWARD], jointQuaternions_[SIT_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[SIT_FORWARD], &jointQuaternions_[SIT_FORWARD]);
    // make loop
	
    jointQuaternions_[SIT_FORWARD] = MakeLoop(jointQuaternions_[SIT_FORWARD],
        jointQuaternions_[SIT_FORWARD].size() / 3,
        jointQuaternions_[SIT_FORWARD].size() * 2 / 3,
        jointQuaternions_[SIT_FORWARD].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[SIT_FORWARD]);


/* ---------------- read the split forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/gymnastic_split.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[SPLIT_FORWARD] = GetRootHeight();
    AssignIndex();
	cout<<"split"<<endl;
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[SPLIT_FORWARD], "./animation/data/gymnastic_split.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[SPLIT_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[SPLIT_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[SPLIT_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[SPLIT_FORWARD].resize(jointTrajectories_[SPLIT_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[SPLIT_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[SPLIT_FORWARD][frameIdx].resize(jointTrajectories_[SPLIT_FORWARD][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[SPLIT_FORWARD], jointQuaternions_[SPLIT_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[SPLIT_FORWARD], &jointQuaternions_[SPLIT_FORWARD]);
    // make loop
	
    jointQuaternions_[SPLIT_FORWARD] = MakeLoop(jointQuaternions_[SPLIT_FORWARD],
        jointQuaternions_[SPLIT_FORWARD].size() / 3,
        jointQuaternions_[SPLIT_FORWARD].size() * 2 / 3,
        jointQuaternions_[SPLIT_FORWARD].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[SPLIT_FORWARD]);


	/* ---------------- read the sneaking forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/sneak_long.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[SNEAK_FORWARD] = GetRootHeight();
    AssignIndex();
	cout<<"sneak"<<endl;
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[SNEAK_FORWARD], "./animation/data/sneak_long.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[SNEAK_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[SNEAK_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[SNEAK_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[SNEAK_FORWARD].resize(jointTrajectories_[SNEAK_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[SNEAK_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[SNEAK_FORWARD][frameIdx].resize(jointTrajectories_[SNEAK_FORWARD][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[SNEAK_FORWARD], jointQuaternions_[SNEAK_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[SNEAK_FORWARD], &jointQuaternions_[SNEAK_FORWARD]);
    // make loop
	
    jointQuaternions_[SNEAK_FORWARD] = MakeLoop(jointQuaternions_[SNEAK_FORWARD],
        jointQuaternions_[SNEAK_FORWARD].size() / 3,
        jointQuaternions_[SNEAK_FORWARD].size() * 2 / 3,
        jointQuaternions_[SNEAK_FORWARD].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[SNEAK_FORWARD]);

	/* ---------------- read the side walking forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/sidewalk_right.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[SIDE_WALK] = GetRootHeight();
    AssignIndex();
	cout<<"sidewalk"<<endl;
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[SIDE_WALK], "./animation/data/sidewalk_right.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[SIDE_WALK]);
    ConvertFromDegreeToRadian(&jointTrajectories_[SIDE_WALK]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[SIDE_WALK]);
    // resize the quaternions array accordingly
    jointQuaternions_[SIDE_WALK].resize(jointTrajectories_[SIDE_WALK].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[SIDE_WALK].size(); ++frameIdx) {
        jointQuaternions_[SIDE_WALK][frameIdx].resize(jointTrajectories_[SIDE_WALK][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[SIDE_WALK], jointQuaternions_[SIDE_WALK]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[SIDE_WALK], &jointQuaternions_[SIDE_WALK]);
    // make loop
	
    jointQuaternions_[SIDE_WALK] = MakeLoop(jointQuaternions_[SIDE_WALK],
        jointQuaternions_[SIDE_WALK].size() / 3,
        jointQuaternions_[SIDE_WALK].size() * 2 / 3,
        jointQuaternions_[SIDE_WALK].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[SIDE_WALK]);

/* ---------------- read the marching forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/march_crop.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[MARCH_FORWARD] = GetRootHeight();
    AssignIndex();
	cout<<"march"<<endl;
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[MARCH_FORWARD], "./animation/data/march_crop.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[MARCH_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[MARCH_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[MARCH_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[MARCH_FORWARD].resize(jointTrajectories_[MARCH_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[MARCH_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[MARCH_FORWARD][frameIdx].resize(jointTrajectories_[MARCH_FORWARD][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[MARCH_FORWARD], jointQuaternions_[MARCH_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[MARCH_FORWARD], &jointQuaternions_[MARCH_FORWARD]);
    // make loop
	
    jointQuaternions_[MARCH_FORWARD] = MakeLoop(jointQuaternions_[MARCH_FORWARD],
        jointQuaternions_[MARCH_FORWARD].size() / 3,
        jointQuaternions_[MARCH_FORWARD].size() * 2 / 3,
        jointQuaternions_[MARCH_FORWARD].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[MARCH_FORWARD]);

/* ---------------- read the kicking forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/kickboxing02.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[KICK_FORWARD] = GetRootHeight();
    AssignIndex();
	cout<<"kick"<<endl;
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[KICK_FORWARD], "./animation/data/kickboxing02.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[KICK_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[KICK_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[KICK_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[KICK_FORWARD].resize(jointTrajectories_[KICK_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[KICK_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[KICK_FORWARD][frameIdx].resize(jointTrajectories_[KICK_FORWARD][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[KICK_FORWARD], jointQuaternions_[KICK_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[KICK_FORWARD], &jointQuaternions_[KICK_FORWARD]);
    // make loop
	
    jointQuaternions_[KICK_FORWARD] = MakeLoop(jointQuaternions_[KICK_FORWARD],
        jointQuaternions_[KICK_FORWARD].size() / 3,
        jointQuaternions_[KICK_FORWARD].size() * 2 / 3,
        jointQuaternions_[KICK_FORWARD].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[KICK_FORWARD]);

	
/* ---------------- read the ducking ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/ducking_long.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[DUCK] = GetRootHeight();
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[DUCK], "./animation/data/ducking_long.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[DUCK]);
    ConvertFromDegreeToRadian(&jointTrajectories_[DUCK]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[DUCK]);
    // resize the quaternions array accordingly
    jointQuaternions_[DUCK].resize(jointTrajectories_[DUCK].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[DUCK].size(); ++frameIdx) {
        jointQuaternions_[DUCK][frameIdx].resize(jointTrajectories_[DUCK][frameIdx].size());
    }
	cout<<"loading ducking.bvh"<<endl;
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[DUCK], jointQuaternions_[DUCK]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[DUCK], &jointQuaternions_[DUCK]);
    // make loop
	
    jointQuaternions_[DUCK] = MakeLoop(jointQuaternions_[DUCK],
        jointQuaternions_[DUCK].size() / 3,
        jointQuaternions_[DUCK].size() * 2 / 3,
        jointQuaternions_[DUCK].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[DUCK]);

/* ---------------- read the skating forward ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/skating_crop.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[SKATE_FORWARD] = GetRootHeight();
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[SKATE_FORWARD], "./animation/data/skating_crop.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[SKATE_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[SKATE_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[SKATE_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[SKATE_FORWARD].resize(jointTrajectories_[SKATE_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[SKATE_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[SKATE_FORWARD][frameIdx].resize(jointTrajectories_[SKATE_FORWARD][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[SKATE_FORWARD], jointQuaternions_[SKATE_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[SKATE_FORWARD], &jointQuaternions_[SKATE_FORWARD]);
    // make loop
	
    jointQuaternions_[SKATE_FORWARD] = MakeLoop(jointQuaternions_[SKATE_FORWARD],
        jointQuaternions_[SKATE_FORWARD].size() / 3,
        jointQuaternions_[SKATE_FORWARD].size() * 2 / 3,
        jointQuaternions_[SKATE_FORWARD].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[SKATE_FORWARD]);


	/* ---------------- read the ballet spin ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/TurnDance.bvh");
	//BalletSpin
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[BALLET_SPIN] = GetRootHeight();
    cout<<"in ballet spin"<<endl;
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[BALLET_SPIN], "./animation/data/TurnDance.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[BALLET_SPIN]);
    ConvertFromDegreeToRadian(&jointTrajectories_[BALLET_SPIN]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[BALLET_SPIN]);
    // resize the quaternions array accordingly
    jointQuaternions_[BALLET_SPIN].resize(jointTrajectories_[BALLET_SPIN].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[BALLET_SPIN].size(); ++frameIdx) {
        jointQuaternions_[BALLET_SPIN][frameIdx].resize(jointTrajectories_[BALLET_SPIN][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[BALLET_SPIN], jointQuaternions_[BALLET_SPIN]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[BALLET_SPIN], &jointQuaternions_[BALLET_SPIN]);
    // make loop
	
    jointQuaternions_[BALLET_SPIN] = MakeLoop(jointQuaternions_[BALLET_SPIN],
        jointQuaternions_[BALLET_SPIN].size() / 3,
        jointQuaternions_[BALLET_SPIN].size() * 2 / 3,
        jointQuaternions_[BALLET_SPIN].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[BALLET_SPIN]);


	/* ---------------- read the tap dance ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/tapDance_crop1.bvh");
	//"./animation/data/tapDance_crop1.bvh"
    rootHeight[TAP_DANCE] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[TAP_DANCE], "./animation/data/tapDance_crop1.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[TAP_DANCE]);
    ConvertFromDegreeToRadian(&jointTrajectories_[TAP_DANCE]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[TAP_DANCE]);
    // resize the quaternions array accordingly
    jointQuaternions_[TAP_DANCE].resize(jointTrajectories_[TAP_DANCE].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[TAP_DANCE].size(); ++frameIdx) {
        jointQuaternions_[TAP_DANCE][frameIdx].resize(jointTrajectories_[TAP_DANCE][frameIdx].size());
    }
	
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[TAP_DANCE], jointQuaternions_[TAP_DANCE]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[TAP_DANCE], &jointQuaternions_[TAP_DANCE]);
    // make loop
	
    jointQuaternions_[TAP_DANCE] = MakeLoop(jointQuaternions_[TAP_DANCE],
        jointQuaternions_[TAP_DANCE].size() / 3,
        jointQuaternions_[TAP_DANCE].size() * 2 / 3,
        jointQuaternions_[TAP_DANCE].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[TAP_DANCE]);
	

	/* ---------------- read the one legged hoppinh ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/chickenhopping03.bvh");
    rootHeight[ONE_HOPPING] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[ONE_HOPPING], "./animation/data/chickenhopping03.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[ONE_HOPPING]);
    ConvertFromDegreeToRadian(&jointTrajectories_[ONE_HOPPING]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[ONE_HOPPING]);
    // resize the quaternions array accordingly
    jointQuaternions_[ONE_HOPPING].resize(jointTrajectories_[ONE_HOPPING].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[ONE_HOPPING].size(); ++frameIdx) {
        jointQuaternions_[ONE_HOPPING][frameIdx].resize(jointTrajectories_[ONE_HOPPING][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[ONE_HOPPING], jointQuaternions_[ONE_HOPPING]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[ONE_HOPPING], &jointQuaternions_[ONE_HOPPING]);
    // make loop
    jointQuaternions_[ONE_HOPPING] = MakeLoop(jointQuaternions_[ONE_HOPPING],
        jointQuaternions_[ONE_HOPPING].size() / 3,
        jointQuaternions_[ONE_HOPPING].size() * 2 / 3,
        jointQuaternions_[ONE_HOPPING].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[ONE_HOPPING]);

	/* ---------------- read the moon walking ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/Moonwalk002.bvh");
    rootHeight[MOONWALK_FORWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[MOONWALK_FORWARD], "./animation/data/Moonwalk002.bvh");

    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[MOONWALK_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[MOONWALK_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[MOONWALK_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[MOONWALK_FORWARD].resize(jointTrajectories_[MOONWALK_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[MOONWALK_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[MOONWALK_FORWARD][frameIdx].resize(jointTrajectories_[MOONWALK_FORWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[MOONWALK_FORWARD], jointQuaternions_[MOONWALK_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[MOONWALK_FORWARD], &jointQuaternions_[MOONWALK_FORWARD]);
    // make loop
    jointQuaternions_[MOONWALK_FORWARD] = MakeLoop(jointQuaternions_[MOONWALK_FORWARD],
        jointQuaternions_[MOONWALK_FORWARD].size() / 3,
        jointQuaternions_[MOONWALK_FORWARD].size() * 2 / 3,
        jointQuaternions_[MOONWALK_FORWARD].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[MOONWALK_FORWARD]);

	/* ---------------- read the cat walking ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/Catwalk002.bvh");//Catwalk002
    rootHeight[CATWALK_FORWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[CATWALK_FORWARD], "./animation/data/Catwalk002.bvh");//Catwalk002
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[CATWALK_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[CATWALK_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[CATWALK_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[CATWALK_FORWARD].resize(jointTrajectories_[CATWALK_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[CATWALK_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[CATWALK_FORWARD][frameIdx].resize(jointTrajectories_[CATWALK_FORWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[CATWALK_FORWARD], jointQuaternions_[CATWALK_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[CATWALK_FORWARD], &jointQuaternions_[CATWALK_FORWARD]);
    // make loop
    jointQuaternions_[CATWALK_FORWARD] = MakeLoop(jointQuaternions_[CATWALK_FORWARD],
        jointQuaternions_[CATWALK_FORWARD].size() / 3,
        jointQuaternions_[CATWALK_FORWARD].size() * 2 / 3,
        jointQuaternions_[CATWALK_FORWARD].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[CATWALK_FORWARD]);


    /* ---------------- read the inplace limping ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/inplace_limping_1_5_cycle.bvh");
    rootHeight[LIMP_INPLACE] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[LIMP_INPLACE], "./animation/data/inplace_limping_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[LIMP_INPLACE]);
    ConvertFromDegreeToRadian(&jointTrajectories_[LIMP_INPLACE]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[LIMP_INPLACE]);
    // resize the quaternions array accordingly
    jointQuaternions_[LIMP_INPLACE].resize(jointTrajectories_[LIMP_INPLACE].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[LIMP_INPLACE].size(); ++frameIdx) {
        jointQuaternions_[LIMP_INPLACE][frameIdx].resize(jointTrajectories_[LIMP_INPLACE][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[LIMP_INPLACE], jointQuaternions_[LIMP_INPLACE]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[LIMP_INPLACE], &jointQuaternions_[LIMP_INPLACE]);
    // make loop
    jointQuaternions_[LIMP_INPLACE] = MakeLoop(jointQuaternions_[LIMP_INPLACE],
        jointQuaternions_[LIMP_INPLACE].size() / 3,
        jointQuaternions_[LIMP_INPLACE].size() * 2 / 3,
        jointQuaternions_[LIMP_INPLACE].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[LIMP_INPLACE]);

    /* ---------------- read the forward limping ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/forward_limping_1_5_cycle.bvh");
    rootHeight[LIMP_FORWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[LIMP_FORWARD], "./animation/data/forward_limping_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[LIMP_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[LIMP_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[LIMP_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[LIMP_FORWARD].resize(jointTrajectories_[LIMP_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[LIMP_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[LIMP_FORWARD][frameIdx].resize(jointTrajectories_[LIMP_FORWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[LIMP_FORWARD], jointQuaternions_[LIMP_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[LIMP_FORWARD], &jointQuaternions_[LIMP_FORWARD]);
    // make loop
    jointQuaternions_[LIMP_FORWARD] = MakeLoop(jointQuaternions_[LIMP_FORWARD],
        jointQuaternions_[LIMP_FORWARD].size() / 3,
        jointQuaternions_[LIMP_FORWARD].size() * 2 / 3,
        jointQuaternions_[LIMP_FORWARD].size() / 3);
    // downsample
    Downsample(jointQuaternions_[LIMP_FORWARD], &jointQuaternions_[LIMP_INPLACE]);
    ForceNoWristRotation(&jointQuaternions_[LIMP_FORWARD]);

    /* ---------------- read the backward limping ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/backward_limping_1_5_cycle.bvh");
    rootHeight[LIMP_BACKWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[LIMP_BACKWARD], "./animation/data/backward_limping_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[LIMP_BACKWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[LIMP_BACKWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[LIMP_BACKWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[LIMP_BACKWARD].resize(jointTrajectories_[LIMP_BACKWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[LIMP_BACKWARD].size(); ++frameIdx) {
        jointQuaternions_[LIMP_BACKWARD][frameIdx].resize(jointTrajectories_[LIMP_BACKWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[LIMP_BACKWARD], jointQuaternions_[LIMP_BACKWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[LIMP_BACKWARD], &jointQuaternions_[LIMP_BACKWARD]);
    // make loop
    jointQuaternions_[LIMP_BACKWARD] = MakeLoop(jointQuaternions_[LIMP_BACKWARD],
        jointQuaternions_[LIMP_BACKWARD].size() / 3,
        jointQuaternions_[LIMP_BACKWARD].size() * 2 / 3,
        jointQuaternions_[LIMP_BACKWARD].size() / 3);
    // downsample
    Downsample(jointQuaternions_[LIMP_FORWARD], &jointQuaternions_[LIMP_BACKWARD]);
    ForceNoWristRotation(&jointQuaternions_[LIMP_BACKWARD]);

    /* ---------------- read the inplace pino walking ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/inplace_pino_walking_1_5_cycle.bvh");
    rootHeight[PINO_WALK_INPLACE] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[PINO_WALK_INPLACE], "./animation/data/inplace_pino_walking_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[PINO_WALK_INPLACE]);
    ConvertFromDegreeToRadian(&jointTrajectories_[PINO_WALK_INPLACE]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[PINO_WALK_INPLACE]);
    // resize the quaternions array accordingly
    jointQuaternions_[PINO_WALK_INPLACE].resize(jointTrajectories_[PINO_WALK_INPLACE].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[PINO_WALK_INPLACE].size(); ++frameIdx) {
        jointQuaternions_[PINO_WALK_INPLACE][frameIdx].resize(jointTrajectories_[PINO_WALK_INPLACE][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[PINO_WALK_INPLACE], jointQuaternions_[PINO_WALK_INPLACE]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[PINO_WALK_INPLACE], &jointQuaternions_[PINO_WALK_INPLACE]);
    // make loop
    jointQuaternions_[PINO_WALK_INPLACE] = MakeLoop(jointQuaternions_[PINO_WALK_INPLACE],
        jointQuaternions_[PINO_WALK_INPLACE].size() / 3,
        jointQuaternions_[PINO_WALK_INPLACE].size() * 2 / 3,
        jointQuaternions_[PINO_WALK_INPLACE].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[PINO_WALK_INPLACE]);

    /* ---------------- read the forward pino walking ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/forward_pino_walking_1_5_cycle.bvh");
    rootHeight[PINO_WALK_FORWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[PINO_WALK_FORWARD], "./animation/data/forward_pino_walking_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[PINO_WALK_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[PINO_WALK_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[PINO_WALK_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[PINO_WALK_FORWARD].resize(jointTrajectories_[PINO_WALK_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[PINO_WALK_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[PINO_WALK_FORWARD][frameIdx].resize(jointTrajectories_[PINO_WALK_FORWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[PINO_WALK_FORWARD], jointQuaternions_[PINO_WALK_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[PINO_WALK_FORWARD], &jointQuaternions_[PINO_WALK_FORWARD]);
    // make loop
    jointQuaternions_[PINO_WALK_FORWARD] = MakeLoop(jointQuaternions_[PINO_WALK_FORWARD],
        jointQuaternions_[PINO_WALK_FORWARD].size() / 3,
        jointQuaternions_[PINO_WALK_FORWARD].size() * 2 / 3,
        jointQuaternions_[PINO_WALK_FORWARD].size() / 3);
    // downsample
    ForceNoWristRotation(&jointQuaternions_[PINO_WALK_FORWARD]);

    /* ---------------- read the backward tiptoeing ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/backward_pino_walking_1_5_cycle.bvh");
    rootHeight[PINO_WALK_BACKWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[PINO_WALK_BACKWARD], "./animation/data/backward_pino_walking_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[PINO_WALK_BACKWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[PINO_WALK_BACKWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[PINO_WALK_BACKWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[PINO_WALK_BACKWARD].resize(jointTrajectories_[PINO_WALK_BACKWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[PINO_WALK_BACKWARD].size(); ++frameIdx) {
        jointQuaternions_[PINO_WALK_BACKWARD][frameIdx].resize(jointTrajectories_[PINO_WALK_BACKWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[PINO_WALK_BACKWARD], jointQuaternions_[PINO_WALK_BACKWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[PINO_WALK_BACKWARD], &jointQuaternions_[PINO_WALK_BACKWARD]);
    // make loop
    jointQuaternions_[PINO_WALK_BACKWARD] = MakeLoop(jointQuaternions_[PINO_WALK_BACKWARD],
        jointQuaternions_[PINO_WALK_BACKWARD].size() / 3,
        jointQuaternions_[PINO_WALK_BACKWARD].size() * 2 / 3,
        jointQuaternions_[PINO_WALK_BACKWARD].size() / 3);
    // downsample
    ForceNoWristRotation(&jointQuaternions_[PINO_WALK_BACKWARD]);
    Downsample(jointQuaternions_[PINO_WALK_BACKWARD], &jointQuaternions_[PINO_WALK_FORWARD]);
    Downsample(jointQuaternions_[PINO_WALK_BACKWARD], &jointQuaternions_[PINO_WALK_INPLACE]);

    /* ---------------- read the inplace tiptoeing ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/inplace_tiptoeing_1_5_cycle.bvh");
    rootHeight[TIPTOE_INPLACE] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[TIPTOE_INPLACE], "./animation/data/inplace_tiptoeing_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[TIPTOE_INPLACE]);
    ConvertFromDegreeToRadian(&jointTrajectories_[TIPTOE_INPLACE]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[TIPTOE_INPLACE]);
    // resize the quaternions array accordingly
    jointQuaternions_[TIPTOE_INPLACE].resize(jointTrajectories_[TIPTOE_INPLACE].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[TIPTOE_INPLACE].size(); ++frameIdx) {
        jointQuaternions_[TIPTOE_INPLACE][frameIdx].resize(jointTrajectories_[TIPTOE_INPLACE][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[TIPTOE_INPLACE], jointQuaternions_[TIPTOE_INPLACE]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[TIPTOE_INPLACE], &jointQuaternions_[TIPTOE_INPLACE]);
    // make loop
    jointQuaternions_[TIPTOE_INPLACE] = MakeLoop(jointQuaternions_[TIPTOE_INPLACE],
        jointQuaternions_[TIPTOE_INPLACE].size() / 3,
        jointQuaternions_[TIPTOE_INPLACE].size() * 2 / 3,
        jointQuaternions_[TIPTOE_INPLACE].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[TIPTOE_INPLACE]);

    /* ---------------- read the forward tiptoeing ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/forward_tiptoeing_1_5_cycle.bvh");
    rootHeight[TIPTOE_FORWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[TIPTOE_FORWARD], "./animation/data/forward_tiptoeing_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[TIPTOE_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[TIPTOE_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[TIPTOE_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[TIPTOE_FORWARD].resize(jointTrajectories_[TIPTOE_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[TIPTOE_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[TIPTOE_FORWARD][frameIdx].resize(jointTrajectories_[TIPTOE_FORWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[TIPTOE_FORWARD], jointQuaternions_[TIPTOE_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[TIPTOE_FORWARD], &jointQuaternions_[TIPTOE_FORWARD]);
    // make loop
    jointQuaternions_[TIPTOE_FORWARD] = MakeLoop(jointQuaternions_[TIPTOE_FORWARD],
        jointQuaternions_[TIPTOE_FORWARD].size() / 3,
        jointQuaternions_[TIPTOE_FORWARD].size() * 2 / 3,
        jointQuaternions_[TIPTOE_FORWARD].size() / 3);
    // downsample
    Downsample(jointQuaternions_[TIPTOE_INPLACE], &jointQuaternions_[TIPTOE_FORWARD]);
    ForceNoWristRotation(&jointQuaternions_[TIPTOE_FORWARD]);

    /* ---------------- read the backward tiptoeing ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/backward_tiptoeing_1_5_cycle.bvh");
    rootHeight[TIPTOE_BACKWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[TIPTOE_BACKWARD], "./animation/data/backward_tiptoeing_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[TIPTOE_BACKWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[TIPTOE_BACKWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[TIPTOE_BACKWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[TIPTOE_BACKWARD].resize(jointTrajectories_[TIPTOE_BACKWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[TIPTOE_BACKWARD].size(); ++frameIdx) {
        jointQuaternions_[TIPTOE_BACKWARD][frameIdx].resize(jointTrajectories_[TIPTOE_BACKWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[TIPTOE_BACKWARD], jointQuaternions_[TIPTOE_BACKWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[TIPTOE_BACKWARD], &jointQuaternions_[TIPTOE_BACKWARD]);
    // make loop
    jointQuaternions_[TIPTOE_BACKWARD] = MakeLoop(jointQuaternions_[TIPTOE_BACKWARD],
        jointQuaternions_[TIPTOE_BACKWARD].size() / 3,
        jointQuaternions_[TIPTOE_BACKWARD].size() / 3,
        jointQuaternions_[TIPTOE_BACKWARD].size() - 1);
    // downsample
    Downsample(jointQuaternions_[TIPTOE_INPLACE], &jointQuaternions_[TIPTOE_BACKWARD]);
    ForceNoWristRotation(&jointQuaternions_[TIPTOE_BACKWARD]);

    /* ---------------- read the inplace jumping ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/inplace_jumping_1_5_cycle.bvh");
    rootHeight[JUMP_SHORT_INPLACE] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[JUMP_SHORT_INPLACE], "./animation/data/inplace_jumping_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[JUMP_SHORT_INPLACE]);
    ConvertFromDegreeToRadian(&jointTrajectories_[JUMP_SHORT_INPLACE]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[JUMP_SHORT_INPLACE]);
    // resize the quaternions array accordingly
    jointQuaternions_[JUMP_SHORT_INPLACE].resize(jointTrajectories_[JUMP_SHORT_INPLACE].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[JUMP_SHORT_INPLACE].size(); ++frameIdx) {
        jointQuaternions_[JUMP_SHORT_INPLACE][frameIdx].resize(jointTrajectories_[JUMP_SHORT_INPLACE][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[JUMP_SHORT_INPLACE], jointQuaternions_[JUMP_SHORT_INPLACE]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[JUMP_SHORT_INPLACE], &jointQuaternions_[JUMP_SHORT_INPLACE]);
    // make loop
    jointQuaternions_[JUMP_SHORT_INPLACE] = MakeLoop(jointQuaternions_[JUMP_SHORT_INPLACE],
        jointQuaternions_[JUMP_SHORT_INPLACE].size() / 3,
        jointQuaternions_[JUMP_SHORT_INPLACE].size() / 3,
        jointQuaternions_[JUMP_SHORT_INPLACE].size() - 1);
    // downsample
    //Downsample(jointQuaternions_[RUN_INPLACE], &jointQuaternions_[RUN_FORWARD]);

    /* ---------------- read the forward jumping ---------------- */

    // read skeleton and assign index to each joint
	//forward_jumping_1_5_cycle
	cout<<"jumping"<<endl;
    BuildSkeletonFromBVH("./animation/data/forward_jumping_1_5_cycle.bvh");
    rootHeight[JUMP_SHORT_FORWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_FORWARD]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[JUMP_SHORT_FORWARD], "./animation/data/forward_jumping_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[JUMP_SHORT_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[JUMP_SHORT_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[JUMP_SHORT_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[JUMP_SHORT_FORWARD].resize(jointTrajectories_[JUMP_SHORT_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[JUMP_SHORT_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[JUMP_SHORT_FORWARD][frameIdx].resize(jointTrajectories_[JUMP_SHORT_FORWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[JUMP_SHORT_FORWARD], jointQuaternions_[JUMP_SHORT_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[JUMP_SHORT_FORWARD], &jointQuaternions_[JUMP_SHORT_FORWARD]);
    // make loop
    jointQuaternions_[JUMP_SHORT_FORWARD] = MakeLoop(jointQuaternions_[JUMP_SHORT_FORWARD],
        jointQuaternions_[JUMP_SHORT_FORWARD].size() / 3,
        jointQuaternions_[JUMP_SHORT_FORWARD].size() * 2 / 3,
        jointQuaternions_[JUMP_SHORT_FORWARD].size() / 3);
    // downsample
    Downsample(jointQuaternions_[JUMP_SHORT_INPLACE], &jointQuaternions_[JUMP_SHORT_FORWARD]);

    /* ---------------- read the long forward jumping ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/forward_jumping_long_1_5_cycle.bvh");
    rootHeight[JUMP_LONG_FORWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[JUMP_FORWARD]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[JUMP_LONG_FORWARD], "./animation/data/forward_jumping_long_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[JUMP_LONG_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[JUMP_LONG_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[JUMP_LONG_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[JUMP_LONG_FORWARD].resize(jointTrajectories_[JUMP_LONG_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[JUMP_LONG_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[JUMP_LONG_FORWARD][frameIdx].resize(jointTrajectories_[JUMP_LONG_FORWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[JUMP_LONG_FORWARD], jointQuaternions_[JUMP_LONG_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[JUMP_LONG_FORWARD], &jointQuaternions_[JUMP_LONG_FORWARD]);
    // make loop
    jointQuaternions_[JUMP_LONG_FORWARD] = MakeLoop(jointQuaternions_[JUMP_LONG_FORWARD],
        jointQuaternions_[JUMP_LONG_FORWARD].size() / 3,
        jointQuaternions_[JUMP_LONG_FORWARD].size() * 2 / 3,
        jointQuaternions_[JUMP_LONG_FORWARD].size() / 3);
    // downsample
    Downsample(jointQuaternions_[JUMP_SHORT_INPLACE], &jointQuaternions_[JUMP_LONG_FORWARD]);
    ForceNoWristRotation(&jointQuaternions_[JUMP_LONG_FORWARD]);

    /* ---------------- read the inplace walking ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/inplace_walking_1_5_cycle.bvh");
    rootHeight[WALK_INPLACE] = GetRootHeight();
    //printf("%.2f\n", rootHeight[WALK_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[WALK_INPLACE], "./animation/data/inplace_walking_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[WALK_INPLACE]);
    ConvertFromDegreeToRadian(&jointTrajectories_[WALK_INPLACE]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[WALK_INPLACE]);
    // resize the quaternions array accordingly
    jointQuaternions_[WALK_INPLACE].resize(jointTrajectories_[WALK_INPLACE].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[WALK_INPLACE].size(); ++frameIdx) {
        jointQuaternions_[WALK_INPLACE][frameIdx].resize(jointTrajectories_[WALK_INPLACE][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[WALK_INPLACE], jointQuaternions_[WALK_INPLACE]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[WALK_INPLACE], &jointQuaternions_[WALK_INPLACE]);
    // make loop
    jointQuaternions_[WALK_INPLACE] = MakeLoop(jointQuaternions_[WALK_INPLACE],
        jointQuaternions_[WALK_INPLACE].size() / 3,
        jointQuaternions_[WALK_INPLACE].size() / 3,
        jointQuaternions_[WALK_INPLACE].size() - 1);

    /* ---------------- read the forward walking ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/forward_walking_1_5_cycle.bvh");
    rootHeight[WALK_FORWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[WALK_FORWARD]);
    AssignIndex();
    // read joint trajectories and process discontinuities
	//"./animation/data/forward_walking_1_5_cycle.bvh"
    ReadBVHFile(&jointTrajectories_[WALK_FORWARD],"./animation/data/forward_walking_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[WALK_FORWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[WALK_FORWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[WALK_FORWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[WALK_FORWARD].resize(jointTrajectories_[WALK_FORWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[WALK_FORWARD].size(); ++frameIdx) {
        jointQuaternions_[WALK_FORWARD][frameIdx].resize(jointTrajectories_[WALK_FORWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[WALK_FORWARD], jointQuaternions_[WALK_FORWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[WALK_FORWARD], &jointQuaternions_[WALK_FORWARD]);
    // make loop
    jointQuaternions_[WALK_FORWARD] = MakeLoop(jointQuaternions_[WALK_FORWARD],
        jointQuaternions_[WALK_FORWARD].size() / 3,
        jointQuaternions_[WALK_FORWARD].size() / 3,
        jointQuaternions_[WALK_FORWARD].size() - 1);
    // downsample
    Downsample(jointQuaternions_[WALK_INPLACE], &jointQuaternions_[WALK_FORWARD]);

    /* ---------------- read the backward walking ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/backward_walking_1_5_cycle.bvh");
    rootHeight[WALK_BACKWARD] = GetRootHeight();
    //printf("%.2f\n", rootHeight[WALK_BACKWARD]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[WALK_BACKWARD], "./animation/data/backward_walking_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[WALK_BACKWARD]);
    ConvertFromDegreeToRadian(&jointTrajectories_[WALK_BACKWARD]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[WALK_BACKWARD]);
    // resize the quaternions array accordingly
    jointQuaternions_[WALK_BACKWARD].resize(jointTrajectories_[WALK_BACKWARD].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[WALK_BACKWARD].size(); ++frameIdx) {
        jointQuaternions_[WALK_BACKWARD][frameIdx].resize(jointTrajectories_[WALK_BACKWARD][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[WALK_BACKWARD], jointQuaternions_[WALK_BACKWARD]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[WALK_BACKWARD], &jointQuaternions_[WALK_BACKWARD]);
    // make loop
    jointQuaternions_[WALK_BACKWARD] = MakeLoop(jointQuaternions_[WALK_BACKWARD],
        jointQuaternions_[WALK_BACKWARD].size() / 3,
        jointQuaternions_[WALK_BACKWARD].size() * 2 / 3,
        jointQuaternions_[WALK_BACKWARD].size() / 3);
    // downsample
    Downsample(jointQuaternions_[WALK_INPLACE], &jointQuaternions_[WALK_BACKWARD]);

    /* ---------------- read the inplace running ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/inplace_running_1_5_cycle.bvh");
    rootHeight[RUN_INPLACE] = GetRootHeight();
    //printf("%.2f\n", rootHeight[RUN_INPLACE]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[RUN_INPLACE], "./animation/data/inplace_running_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[RUN_INPLACE]);
    ConvertFromDegreeToRadian(&jointTrajectories_[RUN_INPLACE]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[RUN_INPLACE]);
    // resize the quaternions array accordingly
    jointQuaternions_[RUN_INPLACE].resize(jointTrajectories_[RUN_INPLACE].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[RUN_INPLACE].size(); ++frameIdx) {
        jointQuaternions_[RUN_INPLACE][frameIdx].resize(jointTrajectories_[RUN_INPLACE][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[RUN_INPLACE], jointQuaternions_[RUN_INPLACE]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[RUN_INPLACE], &jointQuaternions_[RUN_INPLACE]);
    // make loop
    jointQuaternions_[RUN_INPLACE] = MakeLoop(jointQuaternions_[RUN_INPLACE],
        jointQuaternions_[RUN_INPLACE].size() / 3,
        jointQuaternions_[RUN_INPLACE].size() / 3,
        jointQuaternions_[RUN_INPLACE].size() / 3 - 1);

    /* ---------------- read the jogging ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/jogging_1_5_cycle.bvh");
    rootHeight[JOG] = GetRootHeight();
    //printf("%.2f\n", rootHeight[RUN_FORWARD]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[JOG], "./animation/data/jogging_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[JOG]);
    ConvertFromDegreeToRadian(&jointTrajectories_[JOG]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[JOG]);
    // resize the quaternions array accordingly
    jointQuaternions_[JOG].resize(jointTrajectories_[JOG].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[JOG].size(); ++frameIdx) {
        jointQuaternions_[JOG][frameIdx].resize(jointTrajectories_[JOG][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[JOG], jointQuaternions_[JOG]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[JOG], &jointQuaternions_[JOG]);
    // make loop
    jointQuaternions_[JOG] = MakeLoop(jointQuaternions_[JOG],
        jointQuaternions_[JOG].size() / 3,
        jointQuaternions_[JOG].size() / 3,
        jointQuaternions_[JOG].size() - 1);
    ForceNoWristRotation(&jointQuaternions_[JOG]);

    /* ---------------- read the normal running ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/forward_running_normal_1_5_cycle.bvh");
    rootHeight[RUN_NORMAL] = GetRootHeight();
    //printf("%.2f\n", rootHeight[RUN_FORWARD]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[RUN_NORMAL], "./animation/data/forward_running_normal_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[RUN_NORMAL]);
    ConvertFromDegreeToRadian(&jointTrajectories_[RUN_NORMAL]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[RUN_NORMAL]);
    // resize the quaternions array accordingly
    jointQuaternions_[RUN_NORMAL].resize(jointTrajectories_[RUN_NORMAL].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[RUN_NORMAL].size(); ++frameIdx) {
        jointQuaternions_[RUN_NORMAL][frameIdx].resize(jointTrajectories_[RUN_NORMAL][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[RUN_NORMAL], jointQuaternions_[RUN_NORMAL]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[RUN_NORMAL], &jointQuaternions_[RUN_NORMAL]);
    // make loop
    jointQuaternions_[RUN_NORMAL] = MakeLoop(jointQuaternions_[RUN_NORMAL],
        jointQuaternions_[RUN_NORMAL].size() / 3,
        jointQuaternions_[RUN_NORMAL].size() * 2 / 3,
        jointQuaternions_[RUN_NORMAL].size() / 3);
    ForceNoWristRotation(&jointQuaternions_[RUN_NORMAL]);

    /* ---------------- read the long running ---------------- */

    // read skeleton and assign index to each joint
    BuildSkeletonFromBVH("./animation/data/forward_running_long_1_5_cycle.bvh");
    rootHeight[RUN_FAST] = GetRootHeight();
    //printf("%.2f\n", rootHeight[RUN_FORWARD]);
    AssignIndex();
    // read joint trajectories and process discontinuities
    ReadBVHFile(&jointTrajectories_[RUN_FAST], "./animation/data/forward_running_long_1_5_cycle.bvh");
    tree_.ComputMatrix();
    ProcessEulerAngles(&jointTrajectories_[RUN_FAST]);
    ConvertFromDegreeToRadian(&jointTrajectories_[RUN_FAST]);
    // tranlate to origin
    TranslateToOrigin(&jointTrajectories_[RUN_FAST]);
    // resize the quaternions array accordingly
    jointQuaternions_[RUN_FAST].resize(jointTrajectories_[RUN_FAST].size());
    for (int frameIdx = 0; frameIdx < jointTrajectories_[RUN_FAST].size(); ++frameIdx) {
        jointQuaternions_[RUN_FAST][frameIdx].resize(jointTrajectories_[RUN_FAST][frameIdx].size());
    }
    // convert the euler angles to quaternion
    ConvertJointAnglesToQuaternion(jointTrajectories_[RUN_FAST], jointQuaternions_[RUN_FAST]);
    // rotate forward walking frame to inplace walking frame
    RotateFrameBtoOriginal(&jointTrajectories_[RUN_FAST], &jointQuaternions_[RUN_FAST]);
    // make loop
    jointQuaternions_[RUN_FAST] = MakeLoop(jointQuaternions_[RUN_FAST],
        jointQuaternions_[RUN_FAST].size() / 3,
        jointQuaternions_[RUN_FAST].size() * 2 / 3,
        jointQuaternions_[RUN_FAST].size() / 3);
    // downsample
    Downsample(jointQuaternions_[JOG], &jointQuaternions_[RUN_FAST]);
    Downsample(jointQuaternions_[JOG], &jointQuaternions_[RUN_NORMAL]);
    Downsample(jointQuaternions_[JOG], &jointQuaternions_[RUN_INPLACE]);

    /* ---------------- do simple retargeting ---------------- */
    for (int i = 0; i < MODEL_COUNT; ++i)
        SimpleRetarget(rootHeight[RUN_FAST], rootHeight[i], &jointQuaternions_[i]);

    // turns off jacobian computation
    targets_.resize(0);

    Update(0, 1.0, 1.0);
}

/*
 * Assigns one index to each node
 * This number is used to index into the bvh format
 */
void Animation::AssignIndex()
{
    node_[0].SetIndex(0); // Root
    node_[1].SetIndex(2); // Left femur
    node_[2].SetIndex(3); // Left tibia
    node_[3].SetIndex(4); // Left foot
    node_[4].SetIndex(5); // Left toe
    node_[5].SetIndex(-1); // Left toe end
    node_[6].SetIndex(6); // Right femur
    node_[7].SetIndex(7); // Right tibia
    node_[8].SetIndex(8); // Right foot
    node_[9].SetIndex(9); // Right toe
    node_[10].SetIndex(-1); // Right toe end
    node_[11].SetIndex(10); // Lower back
    node_[12].SetIndex(11); // Thorax
    node_[13].SetIndex(12); // Neck
    node_[14].SetIndex(13); // Head
    node_[15].SetIndex(-1); // Head end
    node_[16].SetIndex(14); // Left collar
    node_[17].SetIndex(15); // Left humerus
    node_[18].SetIndex(16); // Left elbow
    node_[19].SetIndex(17); // Left wrist
    node_[20].SetIndex(18); // Left thumb
    node_[21].SetIndex(-1); // Left thumb end
    node_[22].SetIndex(19); // Left wrist end
    node_[23].SetIndex(20); // Right collar
    node_[24].SetIndex(21); // Right humerus
    node_[25].SetIndex(22); // Right elbow
    node_[26].SetIndex(23); // Right wrist
    node_[27].SetIndex(24); // Right thumb
    node_[28].SetIndex(-1); // Right thumb end
    node_[29].SetIndex(25); // Right wrist end
}

/*
 * Builds M
 */
void Animation::BuildVectorM()
{
    M_.resize(3 * k_);

    VectorR3 left(left_->pos.x, left_->pos.y, left_->pos.z);
    VectorR3 right(right_->pos.x, right_->pos.y, right_->pos.z);

    left.z -= kTranslateZ;
    left.x -= kTranslateX;
    double temp = left.x;
    left.x = -left.z;
    left.z = temp;
    left.x /= kScaleX;
    left *= kScale;

    right.z -= kTranslateZ;
    right.x -= kTranslateX;
    temp = right.x;
    right.x = -right.z;
    right.z = temp;
    right.x /= kScaleX;
    right *= kScale;

    //cout << "left " << left.x << " " << left.y << " " << left.z << endl;
    //cout << "right " << right.x << " " << right.y << " " << right.z << endl;

    M_(0) = trajectory_[step_][0].x;
    M_(1) = trajectory_[step_][0].y;
    M_(2) = trajectory_[step_][0].z;
    M_(3) = trajectory_[step_][1].x;
    M_(4) = trajectory_[step_][1].y;
    M_(5) = trajectory_[step_][1].z;

    /*M_(0) = left.x;
    M_(1) = left.y;
    M_(2) = left.z;
    M_(3) = right.x;
    M_(4) = right.y;
    M_(5) = right.z;*/

    //cout << "LEFT" << M_(0) << " " << M_(1) << " " << M_(2) << endl;
    //cout << "RIGHT" << M_(3) << " " << M_(4) << " " << M_(5) << endl;
}

/*
 * Builds N
 */
void Animation::BuildVectorN()
{
    N_ = B_ * M_;
}

/*
 * Builds X
 */
void Animation::BuildMatrixX()
{
    X_.resize(3 * k_, n_);

    for (int i = 0; i < n_; ++i) {
        for (int j = 0; j < k_; ++j) {
            X_(3 * j    , i) = trajectory_[i][j].x;
            X_(3 * j + 1, i) = trajectory_[i][j].y;
            X_(3 * j + 2, i) = trajectory_[i][j].z;
        }
    }
}

/*
 * Builds Z
 */
void Animation::BuildMatrixZ()
{
    Z_.resize(3 * m_, n_);
    for (int i = 0; i < m_; ++i) {
        for (int j = 0; j < n_; ++j) {
            Z_(3 * i    , j) = jointTrajectory_[j][i].x;
            Z_(3 * i + 1, j) = jointTrajectory_[j][i].y;
            Z_(3 * i + 2, j) = jointTrajectory_[j][i].z;
        }
    }
}

/*
 * Builds B
 */
void Animation::BuildMatrixB()
{
    B_ = Z_ * X_.transpose() * (X_ * X_.transpose()).inverse();
}

/*
 * Avoids discontinuities in angles from consecutive frames
 */
void Animation::ProcessEulerAngles(vector<vector<VectorR3>> *trajectory)
{
    for (int i = 1; i < trajectory->size(); ++i) {
        if (i == 0)
            continue;
        for (int j = 1; j < (*trajectory)[i].size(); ++j) {
            VectorR3 &currentRotation = (*trajectory)[i][j];
            VectorR3 &lastRotation = (*trajectory)[i - 1][j];
            if (fabs(currentRotation.x - lastRotation.x) > 90.0f)
                currentRotation.x = -1.0 * Sign(currentRotation.x) *
                (360.0 - fabs(currentRotation.x));
            if (fabs(currentRotation.y - lastRotation.y) > 90.0f)
                currentRotation.y = -1.0 * Sign(currentRotation.y) *
                (360.0 - fabs(currentRotation.y));
            if (fabs(currentRotation.z - lastRotation.z) > 90.0f)
                currentRotation.z = -1.0 * Sign(currentRotation.z) *
                (360.0 - fabs(currentRotation.z));
        }
    }
}

/*
 * Reads the markers' trajectories from a text file
 */
void Animation::ReadMarkers(std::vector<std::vector<VectorR3>> &trajectory, const char *fileName)
{
	ifstream file(fileName);
	string line;

	getline(file, line); // ignore the first empty line

	getline(file, line); // this line stores the markers' names
	istringstream lineStream(line);
	string markerName;
	string temp;
	lineStream >> temp; // the "Frame" string
	int markerNo = 0;
	while (lineStream >> markerName >> temp) {
		markerName = markerName.substr(markerName.find(':') + 1);
		//cout << markerName << " ";
		markers_.push_back(markerName);
	}

	while (getline(file, line)) {
		lineStream.clear();
		lineStream.str(line);

		int frameNo;
		lineStream >> frameNo; // ignore the frame's number

		vector<VectorR3> currentFrame;
		double x, y, z;
		while(lineStream >> x >> y >> z)
			currentFrame.push_back(VectorR3(x, y, z));

		trajectory.push_back(currentFrame);
	}

	file.close();
}

/*
 * Transforms the markers' coordinates to fit with the coordinate frame
   of the program
 */
void Animation::TransformMarkers(std::vector<std::vector<VectorR3>> &trajectory, VectorR3 &scale, VectorR3 &translate)
{
	// Scale the coordinates of the markers to fit with the coordinate frame
	// of the program
	// The scale factor should be different for each set of data
	for (vector<vector<VectorR3>>::iterator it = trajectory.begin();
		it < trajectory.end();
		++it) {
			for (vector<VectorR3>::iterator v = (*it).begin();
				v < (*it).end();
				++v) {
					(*v).x /= scale.x;
					(*v).y /= scale.y;
					(*v).z /= scale.z;
			}
	}

	// Translate the left ankle marker to the left ankle of the skeleton
	double x = trajectory[0][0].x - translate.x;
	double y = trajectory[0][0].y - translate.y;
	double z = trajectory[0][0].z - translate.z;
	for (vector<vector<VectorR3>>::iterator it = trajectory.begin();
		it < trajectory.end();
		++it) {
			for(vector<VectorR3>::iterator v = (*it).begin();
				v < (*it).end();
				++v) {
					(*v).x -= x;
					(*v).y -= y;
					(*v).z -= z;
			}
	}
}

/*
 * Prints the transformed markers' data to a text file for debugging
 */
void Animation::PrintMarkers(vector<vector<VectorR3>> &trajectory, char *fileName)
{
    ofstream file(fileName);
    if (file.is_open()) {
        int frameNo = 1;
        for (vector<vector<VectorR3>>::const_iterator it = trajectory.begin();
                                                      it < trajectory.end();
                                                      ++it) {
            file << setw(5) << setfill (' ') << frameNo++ << "    ";
            file << setprecision(3) << fixed;
            for (vector<VectorR3>::const_iterator v = (*it).begin();
                                                  v < (*it).end();
                                                  ++v) {
                file << setw(8) << (*v).x << " " <<
                        setw(8) << (*v).y << " " <<
                        setw(8) << (*v).z << " ; ";
            }
            file << endl;
        }
    }
} 

/*
 * Reads data from a bvh file
 */
void Animation::ReadBVHFile(vector<vector<VectorR3>> *trajectory, const char *fileName)
{
    trajectory->clear();

    ifstream file(fileName);
    string line;

    getline(file, line);
    while (line.compare("MOTION") != 0)
        getline(file, line);

	getline(file, line); // Frames: xxx
    getline(file, line); // Frame Time: xxx

    while (getline(file, line)) {
        istringstream lineStream(line);

        vector<VectorR3> currentFrame;
        double x, y, z;
        while(lineStream >> x >> y >> z)
            currentFrame.push_back(VectorR3(x, y, z));

        trajectory->push_back(currentFrame);
    }

    file.close();
}

//added by david
//update the orientation of the character
void Animation::rotate_character(double angle)
{
	character_orientation += angle;

	//keep the value of character_orientation between 0 and 2*PI
	while (character_orientation<0)
		character_orientation += 4*asin(1.0);
	while (character_orientation>4*asin(1.0))
		character_orientation -= 4*asin(1.0);

	 node_[0].SetQuaternion(Quaternion2().getRotationQuaternion2(character_orientation, VectorR3(0.0, 1.0, 0.0))*currentMotion_[step_][1]); //added
	//VectorR3 newPos = currentMotion_[step_][0].ToPoint();
    //VectorR3 currPos = node_[0].GetLocalPosition();
    //node_[0].SetPosition(currPos.x + newPos.x*cos(character_orientation)+newPos.z*sin(character_orientation), newPos.y,
	//						currPos.z + newPos.z*cos(character_orientation)-newPos.x*sin(character_orientation));
}

void Animation::move_joint_by_delta(double dx, double dy, double dz, Joint_Name jn)
{
	VectorR3 v = node_[jn].GetGlobalPosition();
	Point3d pt = Point3d(v.x, v.y, v.z) + Vector3d(dx, dy, dz);
	move_joint(pt, jn);
}


void Animation::move_joint(Point3d pt, Joint_Name jn)
{
	//check if the joint is not the root
	if (joint_parent[jn]!=-1)
	{
		//store the parent's index
		int jn_p = joint_parent[jn];

		//check if the parent is not the root
		if (joint_parent[jn_p]!=-1)
		{
			//store the grandparent's index
			int jn_gp = joint_parent[jn_p];

			//convert the position of grand parent to Point3d
			VectorR3 v1 = node_[jn_gp].GetGlobalPosition();
			Point3d p1(v1.x, v1.y, v1.z);

			//convert the position of the parent to Point3d2
			VectorR3 v2 = node_[jn_p].GetGlobalPosition();
			Point3d p2(v2.x, v2.y, v2.z);

			//convert the position of the joint to Point3d2
			VectorR3 v3 = node_[jn].GetGlobalPosition();
			Point3d p3(v3.x, v3.y, v3.z);

			//store the change in rotation of the grandparent and parent into qrot1 and qrot2 respectively
			Quaternion2 q1, q2;
			//do two link inverse kinematic to update quaternion rotation of the grand parent
			Point3d p2_new = compute_twoLinkIK(pt, p1, p2, p3, q1, q2);

			node_[jn_gp].SetQuaternion(node_[jn_gp].GetGlobalQuaternion().getInverse()*
										q1*node_[jn_gp].GetGlobalQuaternion()*
										node_[jn_gp].GetQuaternion());

			//for debugging
			//printf("%lf %lf\n", qrot1.getAngle(), qrot2.getAngle());
/*
			//update the quaternion rotation and joint position of all the descendants of the target joint's grand parent except the parent
			modified_joint_quaternion[jn_gp][frameNumber].rotate(qrot1.getAngle(), qrot1.getXaxis(), qrot1.getYaxis(), qrot1.getZaxis());
			for (int i=0; i<(int)joint_child[jn_gp].size(); i++)
			{
				if (joint_child[jn_gp][i]!=jn_p)
				{
					update_after_move_joint(frameNumber, qrot1, jn_gp, joint_child[jn_gp][i]);
				}
			}

			//update the new position of the parent
			modified_joint_position[jn_p][frameNumber] = Point3d2(p2_new.x, p2_new.y, p2_new.z);

			//update the quaternion rotation and joint position of the descendant of the target joint's parent
			modified_joint_quaternion[jn_p][frameNumber].rotate(qrot2.getAngle(), qrot2.getXaxis(), qrot2.getYaxis(), qrot2.getZaxis());
			for (int i=0; i<(int)joint_child[jn_p].size(); i++)
			{
				update_after_move_joint(frameNumber, qrot2, jn_p, joint_child[jn_p][i]);
			}

			//for debugging
			/*printf("%lf %lf %lf\n", modified_joint_position[jn][frameNumber].x,
									modified_joint_position[jn][frameNumber].y,
									modified_joint_position[jn][frameNumber].z);/**/
		}
	}
}

//compute two link inverse kinematic
//all calculations are done in global coordinate
Point3d Animation::compute_twoLinkIK(Point3d pt, Point3d p1, Point3d p2, Point3d p3,
									Quaternion2& qrot1, Quaternion2& qrot2)
{
	Vector3d delta(p3, pt);
	//check if the displacement is still in the computational limit of double
	//for smaller value of the limit, the computation may fail to resolve the number
	if (delta.length()>1e-5)
	{
		//compute the normal vector of p1, p2, and p3
		Vector3d n = Vector3d(p2, p1).crossProductWith(Vector3d(p2, p3)).toUnit();

		//modify n so that it's perpendicular to the vector (p1, pt), and still as close as possible to n
		Vector3d line = Vector3d(p1, pt);
		Vector3d n_new = (line.crossProductWith(n.crossProductWith(line))*(1)).toUnit();

		//now compute the new position of the child joint
		//The solution for this comes from computation of the intersection of two circles of radii r1 and r2,
		//located at p1 and p2 respectively. There are, of course, two solutions to this problem.
		//The calling application can differentiate between these by passing in n or -n for the plane normal.
		//This is the distance between p1 and p2. If it is > r1+r2, then we have no solutions.
		//To be nice about it, we will set r to r1+r2 - the behaviour will be to reach as much as possible,
		//even though you don't hit the target
		double r = Vector3d(p1, pt).length();
		double r1 = Vector3d(p1, p2).length();
		double r2 = Vector3d(p2, p3).length();
		if (r > (r1+r2) * 0.993)
			r = (r1 + r2) * 0.993;
		//this is the length of the vector starting at p1 and going to the midpoint between p1 and pt
		double a = (r1 * r1 - r2 * r2 + r * r) / (2 * r);
		double tmp = r1*r1 - a*a;
		if (tmp < 0)
			tmp = 0;
		//and this is the distance from the midpoint of p1-p2 to the intersection point
		double h = sqrt(tmp);
		//now we need to get the two directions needed to reconstruct the intersection point
		Vector3d d1 = Vector3d(p1, pt).toUnit();
		Vector3d d2 = d1.crossProductWith(n_new).toUnit();
		//and now get the intersection point
		Point3d p2_new = p1 + d1 * a + d2 * (-h);

		//compute the new quaternion of the parent joint
		Vector3d v1 = Vector3d(p1, p2).toUnit();
		Vector3d v1_new = Vector3d(p1, p2_new).toUnit();
		double angle1 = acos(v1.dotProductWith(v1_new));
		const Vector3d axis1 = v1.crossProductWith(v1_new).toUnit();
		qrot1.Set(angle1, VectorR3(axis1.x, axis1.y, axis1.z));

		//compute the new quaternion of the child joint
		Vector3d v2 = Vector3d(p2, p3).toUnit();
		Vector3d v2_new = Vector3d(p2_new, pt).toUnit();

		//for debugging
		//printf("%lf %lf %lf\n", v2.x, v2.y, v2.z);
		//printf("%lf %lf %lf\n", v2_new.x, v2_new.y, v2_new.z);
		//printf("%lf\n", v2.toUnit().dotProductWith(v2_new.toUnit()));
		double angle2 = acos(v2.dotProductWith(v2_new));
		//for debugging
		//printf("%lf\n", angle2);
		const Vector3d axis2 = v2.crossProductWith(v2_new).toUnit();
		qrot2.Set(angle2, VectorR3(axis2.x, axis2.y, axis2.z));

		return p2_new;
	}
	//if the displacement is below the threshold, set the variables to default values
	else
	{
		qrot1.Set(0.0, 1.0, 0.0, 0.0);
		qrot2.Set(0.0, 1.0, 0.0, 0.0);
		return p2;
	}
}/**/

void Animation::compute_joint_parent()
{
	joint_parent.resize(30);
	//root
	joint_parent[Root] = -1;
	//left leg
	joint_parent[L_Femur] = Root;
	joint_parent[L_Tibia] = L_Femur;
	joint_parent[L_Foot] = L_Tibia;
	joint_parent[L_Toe] = L_Foot;
	joint_parent[L_Toe_End] = L_Toe;
	//right leg
	joint_parent[R_Femur] = Root;
	joint_parent[R_Tibia] = R_Femur;
	joint_parent[R_Foot] = R_Tibia;
	joint_parent[R_Toe] = R_Foot;
	joint_parent[R_Toe_End] = R_Toe;
	//upper body
	joint_parent[LowerBack] = Root;
	joint_parent[Thorax] = LowerBack;
	joint_parent[Neck] = Thorax;
	joint_parent[Head] = Neck;
	joint_parent[Head_End] = Head;
	//left arm
	joint_parent[L_Collar] = Thorax;
	joint_parent[L_Humerus] = L_Collar;
	joint_parent[L_Elbow] = L_Humerus;
	joint_parent[L_Wrist] = L_Elbow;
	joint_parent[L_Thumb] = L_Wrist;
	joint_parent[L_Thumb_End] = L_Thumb;
	joint_parent[L_Wrist_End] = L_Wrist;
	//right arm
	joint_parent[R_Collar] = Thorax;
	joint_parent[R_Humerus] = R_Collar;
	joint_parent[R_Elbow] = R_Humerus;
	joint_parent[R_Wrist] = R_Elbow;
	joint_parent[R_Thumb] = R_Wrist;
	joint_parent[R_Thumb_End] = R_Thumb;
	joint_parent[R_Wrist_End] = R_Wrist;
}